\documentclass{mproj}
\usepackage{graphicx}

\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{fancyvrb}
\usepackage[final]{pdfpages}
\usepackage{times}
\usepackage{todonotes}
\usepackage{titlesec}
\usepackage{enumitem}
\setlist{nolistsep}
\usepackage{listings}
\input{lstcoq.sty}

% Inference rules
\usepackage{mathpartir}

% Links and their colors
\usepackage[
  colorlinks=true,
  linkcolor=darkgray,
  citecolor=darkgray,
  urlcolor=darkgray,
  ]{hyperref}

% Use a single line for chapter headers
\titleformat{\chapter}[hang]{\normalfont\huge\bfseries}{\thechapter.}{1em}{} 
% Remove the space before chapter titles
\titlespacing*{\chapter}{0pt}{0pt}{40pt}

% Appendices
\usepackage[header,title,titletoc]{appendix}
\renewcommand{\appendixname}{Appendix}

% License
\usepackage[
    type={CC},
    modifier={by-sa},
    version={3.0},
]{doclicense}

% Add bibliography to TOC
\usepackage[nottoc,numbib]{tocbibind}

\newtheorem{theorem}{Theorem}

% Commands for the pi-calculus
\newcommand{\PO}{\mathbf{0}}
\newcommand{\comp}[2]{#1 \mid #2}
\newcommand{\new}[2]{(\boldsymbol{\nu} #1 #2)}
\newcommand{\cout}[2]{\overline{#1}\langle#2\rangle.}
\newcommand{\cin}[2]{#1(#2)}
\newcommand{\select}[2]{#1\triangleleft#2.}
\newcommand{\branch}[2]{#1\triangleright#2}

\newcommand{\subst}[3]{#1[#2/#3]}

\def\picalc/{\(\pi\)-calculus}
\def\Picalc/{\(\pi\)-Calculus}

\newcommand{\type}{\texttt}
\newcommand{\End}{\type{End}}
\newcommand{\Send}[1]{!#1.}
\newcommand{\Recv}[1]{?#1.}
\newcommand{\Select}{\oplus}
\newcommand{\Branch}{\&}
\newcommand{\dual}{\overline}

\newcommand{\reduce}{\rightarrow}
\renewcommand{\emptyset}{\varnothing}
\newcommand{\types}{\vdash}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Type-checking\\ $\pi$-calculus session types\\ with Coq}
\author{Uma Zalakain}
\date{2019-09-06}
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
    This project formalises session types in Coq using a mix of continuation
    passing, parametric HOAS, dependent types and ad-hoc linearity checks. Each
    action that a process takes requires a channel capable of that action. The
    head of that channel's type is then stripped off and its continuation is
    passed to the next action the process takes. Dependent types guarantee this
    continuation passing is correct by construction. The type of channels is
    parametrised over, so that users are unable to skip the proper mechanisms to
    create channels. The HOAS makes the syntax easy to use for both the end user
    and the designer: all variables are lifted to Coq, all typing judgments
    happen in Coq, no typing contexts are required. The continuation passing
    always creates channels that must be used exactly once. Unfortunately Coq
    has no linearity support, so this check needs to happen ad-hoc, by
    traversing processes. Ultimately, the claim is this: if the definition of a
    process typechecks in Coq, and the process uses channels linearly, then type
    safety and type preservation through reduction hold.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\educationalconsent
\vfill{}
\doclicenseThis
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgements}

Acknowledgements go here

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}\label{intro}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The pi calculus models the exchange of messages between agents over two-endpoint
communication channels. When two agents exchange a message over a channel
computation advances: the receiving agent gets reduced through substitution; the
sending agent proceeds further. Channels are typed, limiting the data that can
be exchanged over them. A further introduction to the pi calculus is provided in
\S \ref{pi-calculus}.

Session types add sequential types to channels: the session type of a channel
endpoint is a finite sequence of types, each with an associated direction.  When
a channel endpoint is used by an agent, the type and direction of the exchanged
data must follow the specification of the associated session type. The theorems
enabled by this type system are found in \S \ref{session-types}.

Using a proof assistant to prove these theorems provides an exceptionally strong
guarantee of their correctness. Moreover, it means that any agent that uses
session types as an abstraction can have these theorems automatically derived
for it. From the numerous proof assistants available, this project uses Coq to
formalise the pi calculus with session types. Amongst its features, Coq includes
a powerful tactic engine and a dependent type system, both key for the
development of this project. An overview of Coq is given in \S \ref{coq}.

The present work takes advantage of polymorphism (\S \ref{polymorphism}) and
dependent types (\S \ref{dependent-types}) and uses a parametric higher-order
abstract syntax (\S \ref{phoas}) and continuation passing (\S
\ref{continuation-passing}) to \textbf{discharge the type-checking of pi
calculus terms on Coq}. However, this method relies on channel endpoints being
used exactly once, i.e. linearly (\S \ref{linearity}). Coq does not support
linearity, and thus this check will have to be addressed ad-hoc. Once a
linearity check is available, the type-checking of terms is decidable and
\textbf{variable references, typing contexts and typing judgments can be lifted
to the host language}. The details of how this is carried out in practice are
explained in \S \ref{implementation}.

Past efforts in formalising session types in Coq have created object languages
and handled variable references, typing contexts, and typing judgments by hand
\cite{Dilmore2019}. These and other approaches are mentioned in \S
\ref{related-work}.

Finally, \S \ref{conclusion} suggests future work that might be of interest, and
offers conclusions on what this project has achieved.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Background knowledge}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Discuss general pi calculus
Discuss session types
Discuss our subset of session types
Overview Coq
Polymorphism
Dependent types


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Pi calculus}\label{pi-calculus}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\cite{Vasconcelos2009}
\todo{Channels as messages}
\todo{Limit ourselves to binary channels}
\todo{Typed only as \#T}

\begin{align*}
P,Q ::= \; &\PO                                 & \text{inaction}             \\
           &\new{x}{y}P                         & \text{scope restriction}    \\
           &\cout{x}{u}P                        & \text{output}               \\
           &\cin{y}{u}P                         & \text{input}                \\
           &\select{x}{l_j}P                    & \text{selection}            \\
           &\branch{x}{\{l_i : P_i\}_{i \in I}} & \text{branching}            \\
           &\comp{P}{Q}                         & \text{parallel composition}
\end{align*}

\begin{mathpar}
\inferrule
    { }
    {\comp{P}{Q} \equiv \comp{Q}{P}}
    \quad (\textsc{C-CompComm})

\inferrule
    { }
    {\new{x}{y} \new{z}{w} P \equiv \new{z}{w} \new{x}{y} P}
    \quad (\textsc{C-ScopeComm})

\inferrule
    { }
    {\comp{P}{\PO} \equiv P}
    \quad (\textsc{C-Comp0})

\inferrule
    { }
    {\comp {\comp{P}{Q}} {R} \equiv \comp {P} {\comp{Q}{R}}}
    \quad (\textsc{C-CompAssoc})

\inferrule
    { }
    {\new{x}{y} \PO \equiv \PO}
    \quad (\textsc{C-Scope0})

\inferrule
    {x,y \not\in fn(Q)}
    {\comp {\new{x}{y}P} {Q} \equiv \new{x}{y} \comp{P}{Q}}
    \quad (\textsc{C-ScopeExp})

\inferrule
    { }
    {\new{x}{y}P \equiv \new{y}{x}P}
    \quad (\textsc{C-ScopeSwap})
\end{mathpar}

\begin{mathpar}
\inferrule 
    { }
    {\new{x}{y}(\comp {\cout{x}{a}P} {\cin{y}{b}Q}) \reduce
     \new{x}{y}(\comp {P}            {\subst{Q}{a}{b}})}
    \quad (\textsc{R-Comm})

\inferrule
    {j \in I}
    {\new{x}{y}(\comp {\select{x}{l_j}P} {\branch{y}{\{l_i : Q_i\}_{i \in I}}}) \reduce
     \new{x}{y}(\comp {P}                {Q_j})}
    \quad (\textsc{R-Case})

\inferrule
    {P \reduce Q}
    {\new{x}{y}P \reduce \new{x}{y}Q}
    \quad (\textsc{R-Res})

\inferrule
    {P \reduce Q}
    {\comp{P}{R} \reduce \comp{Q}{R}}
    \quad (\textsc{R-Par})

\inferrule
    {P \equiv P' \\ P' \reduce Q' \\ Q' \equiv Q}
    {P \reduce Q}
    \quad (\textsc{R-Struct})
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Session types}\label{session-types}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo{Can be binary (diadic) or multiparty}
\todo{Channels as messages}
\todo{Guarantees}
\todo{Limit ourselves to channels with session types, no \#T}
\todo{Limit ourselves to linear types: $\circ$ is union of non intersecting sets}

The two endpoints of a channel must have dual session types: if one end is
sending data of type \texttt{T}, the other must be receiving data of type
\texttt{T} -- ensuring \textit{communication safety}. Channel endpoints can be
passed along as messages, but can never be duplicated: communication must only
ever occur between two agents -- ensuring \textit{privacy}. Agents must
follow the session types of channel endpoints: channels must be used as per
their specification -- ensuring \textit{session fidelity}. As communication
occurs and messages are exchanged, the session types of channels advance.
Ensuring that this reduction process respects session types involves proving
both \textit{subject reduction} and \textit{type soundness}. \cite{Dardha2016m}

\begin{mathpar}
\inferrule{}{\dual{\Send{T}S} = \Recv{T}\dual{S}}

\inferrule{}{\dual{\Recv{T}S} = \Send{T}\dual{S}}

\inferrule{}{
    \dual{\Branch \{l_i : S_i\}_{i \in I}} =
    \Select \{l_i : \dual{S_i}\}_{i \in I}}

\inferrule{}{
    \dual{\Select\{l_i : S_i\}_{i \in I}} =
    \Branch \{l_i : \dual{S_i}\}_{i \in I}}

\inferrule{}{\dual{\End} = \End}
\end{mathpar}

\begin{mathpar}
\inferrule
    {\Gamma \types x : \End}
    {\Gamma \types \PO}
    \quad (\textsc{T-Inact})

\inferrule
    {\Gamma_1 \types P \\
     \Gamma_2 \types Q}
    {\Gamma_1 \circ \Gamma_2 \types \comp{P}{Q}}
    \quad (\textsc{T-Par})

\inferrule
    {\Gamma,x:T,y:\dual{T} \types P}
    {\Gamma \types \new{x}{y}P}
    \quad (\textsc{T-Res})

\inferrule
    {\Gamma_1 \types x:\Recv{T}S \\
     \Gamma_2,x:S,y:T \types P}
    {\Gamma_1 \circ \Gamma_2 \types \cin{x}{y}P}
    \quad (\textsc{T-In})

\inferrule
    {\Gamma_1 \types x:\Send{T}S \\
     \Gamma_2 \types v:T \\
     \Gamma_3,x:S \types P}
    {\Gamma_1 \circ \Gamma_2 \circ \Gamma_3 \types \cout{x}{v}P}
    \quad (\textsc{T-Out})

\inferrule
    {\Gamma_1 \types x:\Branch{\{l_i : S_i\}_{i \in I}} \\
     \Gamma_2,x:S_i \types P_i \\
     \forall i \in I}
    {\Gamma_1 \circ \Gamma_2 \types x \branch{\{l_i : P_i\}_{i \in I}}}
    \quad (\textsc{T-Branch})

\inferrule
    {\Gamma_1 \types x:\Select{\{l_i : S_i\}_{i \in I}} \\
     \Gamma_2,x:S_i \types P_i \\
     \exists j \in I}
    {\Gamma_1 \circ \Gamma_2 \types x \select{l_j}P}
    \quad (\textsc{T-Select})
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Coq proof assistant}\label{coq}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo{Powerful tactics}
\todo{Not so good with dependent types}
\todo{Equations package}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Polymorphism}\label{polymorphism}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cite{Wadler1989}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Dependent types}\label{dependent-types}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\todo{Indexed datatypes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Encoding}\label{encoding}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Parametric HOAS}\label{phoas}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cite{Wadler1989}
\cite{Chlipala2008}
\todo{We use polymorphism to make channels opaque}
\todo{We do not do open processes}
\todo{We use polymorphism on messages to make processes traversable}

The introduction of both channels and received messages is modelled as function
abstraction in Coq, therefore \textbf{variables are handled transparently} -- no
substitution related lemmas are required. Channel types are parametrised to make
them opaque -- they cannot be illicitly created or inspected by the user.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Continuation passing}\label{continuation-passing}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cite{Vasconcelos2010}
\todo{We merge pi calculus and session types into one}

Assuming linearity, \textbf{processes are correct by construction}: the
processes that can be constructed depend on the session types of the channels in
the environment of the host language; an action strips off the outer layer of a
channel's session type -- modelling \textbf{continuation passing}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Linearity}\label{linearity}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cite{Kobayashi1999}
\cite{Toninho2011}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Type preservation}\label{type-preservation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Ensuring that linearity is preserved through reduction is therefore essential:
\begin{theorem}
    $lin(P) \Rightarrow P \rightarrow Q \Rightarrow lin(Q).$
\end{theorem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation}\label{implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Processes}\label{processes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Congruence}
\subsection{Reduction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Linearity check}\label{linearity-check}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Linearity preservation}\label{linearity-preservation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Results}\label{results}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Related work}\label{related-work}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}\label{conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{plain}
\bibliography{mproj}
\end{document}
