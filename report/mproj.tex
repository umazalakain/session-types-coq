\documentclass{mproj}

\usepackage[utf8]{inputenc}

% Coq code
\usepackage[dvipsnames]{xcolor}
\usepackage{listings}
\input{lstcoq.sty}

% Math
\usepackage{amsmath}
\usepackage{amssymb}

% Use times font
\usepackage{times}

% They are all over the place
\usepackage{todonotes}

% Allows to place figures HERE!
\usepackage{float}

% Enums
\usepackage{enumitem}
\setlist{nolistsep}

% Inference rules
\usepackage{mathpartir}

% Links and their colors
\usepackage{url}
\usepackage[
  colorlinks=true,
  linkcolor=darkgray,
  citecolor=darkgray,
  urlcolor=darkgray,
  ]{hyperref}

\usepackage{titlesec}
% Use a single line for chapter headers
\titleformat{\chapter}[hang]{\normalfont\huge\bfseries}{\thechapter.}{1em}{} 
% Remove the space before chapter titles
\titlespacing*{\chapter}{0pt}{0pt}{40pt}

% Appendices
\usepackage[header,title,titletoc]{appendix}
\renewcommand{\appendixname}{Appendix}

% License
\usepackage[
    type={CC},
    modifier={by-sa},
    version={3.0},
]{doclicense}

\usepackage[many]{tcolorbox}
\newtcolorbox{thesis-statement}[1]{%
    tikznode boxed title,
    enhanced,
    arc=0mm,
    interior style={white},
    attach boxed title to top center= {yshift=-\tcboxedtitleheight/2},
    fonttitle=\bfseries,
    colbacktitle=white,coltitle=black,
    boxed title style={size=normal,colframe=white,boxrule=0pt},
    title={#1}}

% Add bibliography to TOC
\usepackage[nottoc,numbib]{tocbibind}

% Switch off page numbering for noe
\pagenumbering{gobble}


\newtheorem{theorem}{Theorem}

% Commands for the pi-calculus
\newcommand{\PO}{\mathbf{0}}
\newcommand{\comp}[2]{#1 \mid #2}
\newcommand{\new}[2]{(\boldsymbol{\nu} #1 #2) \;}
\newcommand{\cout}[2]{\overline{#1}\langle#2\rangle.}
\newcommand{\cin}[2]{#1(#2).}
\newcommand{\select}[2]{#1\triangleleft#2.}
\newcommand{\branch}[2]{#1\triangleright#2}
\newcommand{\subst}[3]{#1[#2/#3]}
\newcommand{\picalc}{$\pi$-calculus}
\newcommand{\Picalc}{$\pi$-Calculus}
\newcommand{\type}{\texttt}
\newcommand{\End}{\type{End}}
\newcommand{\Send}[1]{!#1.}
\newcommand{\Recv}[1]{?#1.}
\newcommand{\Select}{\oplus}
\newcommand{\Branch}{\&}
\newcommand{\dual}{\overline}
\newcommand{\reduce}{\rightarrow}
\renewcommand{\emptyset}{\varnothing}
\newcommand{\types}{\vdash}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Type-checking\\ session-typed \picalc \\ with Coq}
\author{Uma Zalakain}
\date{2019-09-06}
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
\todo{go over this again}
    This project formalises the session-typed \picalc{} in Coq using a mix of continuation passing, parametric HOAS, dependent types and ad-hoc linearity checks. Each action a process takes requires a channel capable of that action. The head of that channel's type is then stripped off and its continuation is passed to the next action the process takes. Dependent types guarantee this continuation passing is correct by construction. The type of channels is parametrised over, so that users are unable to skip the proper mechanisms to create channels. The HOAS makes the syntax easy to use for both the end user and the designer: all variables are lifted to Coq, no typing contexts are required. The continuation passing always creates channels that must be used exactly once, but unfortunately Coq has no support for linearity, so this check needs to happen ad-hoc, by traversing processes. Ultimately, the claim is this: if the definition of a process typechecks in Coq, and the process uses channels linearly, then type safety and type preservation through reduction hold.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\educationalconsent
\vfill{}
\doclicenseThis
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgements}

Acknowledgements go here

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}\label{intro}
% Start page numbering here
\pagenumbering{arabic}

During the last decades, while the frequency at which processors run has peaked, the number of available processing units has kept growing. Computing has consequently shifted its focus into making processes safely communicate with one another --- no matter if they run concurrently on different CPU cores or on different hosts. The interest in the formalisation and verification of \emph{communicating concurrent} systems (where processes share no state and change as communication occurs) has grown as a result.

Communicating concurrent processes must satisfy some safety properties, such as following a pre-established communication protocol (where all messages sent by one process are expected by the other and vice versa) or communicating over private channels only known to the involved participants. To make properties like these easier to prove, formal models such as the \emph{\picalc{}} \cite{Walker1989,Milner1989,Milner1991,Sangiorgi2001} abstract real-world systems into suitable mathematical representations. \S \ref{pi-calculus} provides a brief overview of the \picalc.

The properties of a formal system can be verified either \emph{dynamically}, by monitoring processes at runtime, or \emph{statically}, by reasoning on the definition of the processes themselves.  Static guarantees --- while harder to define and sometimes more conservative than dynamic ones --- are \emph{total}, and thus satisfied regardless of the execution path. The basis of static verification is comprised of \emph{types} and \emph{type systems}, which are also the basis of programming languages and tools, making type-based verification techniques transferable to practical applications. An example of this are the plethora of types for communication and process calculi: from standard channel types, as found in e.g., Erlang or Go, to \emph{session types} \cite{Honda1993, Takeuchi1994, Honda1998}, a formalism used to specify and verify communication protocols (more in \S \ref{session-types}).

\todo{move session type definition and properties up here?}

The mechanised formalisation and verification of programming languages and calculi is an ongoing community effort in securing existing work: humans are able to check proofs, but they are very likely to make mistakes; machines can verify proofs mechanically. A remarkable example of a community effort towards machine verification is RustBelt \cite{Dreyer2018}, a project that aims to formalise and machine-check the ownership system of the programming language Rust with the help of separation logic \cite{} and the proof assistant Coq. Not only does mechanisation increase confidence in what is mechanised, but also in all other derived work that is yet unverified: proving the correctness of Rust's type system immediately increases the confidence in all software written in it.

\begin{thesis-statement}{THESIS STATEMENT}
    This project formalises the \emph{session-typed \picalc{}} in such a way that variable references in the object language are lifted into variable references in the host language. The use of channels in the object language is then restricted to be linear, ensuring \emph{communication privacy}, \emph{communication safety} and \emph{session fidelity} (refer to \S \ref{session-types-properties}). Lastly, we machine-verify \emph{subject reduction} for the resulting language.
\end{thesis-statement}

\todo{mention we have no shared channels and no recursive session types}

We choose Coq \cite{Coquand1989, CoqDeveloperCommunity} to machine-verify the session-typed \picalc{}, mainly due to its widespread use as a proof assistant (refer to \S \ref{coq} for an overview). A first challenge with Coq is that it offers \emph{no} support for \emph{linearity}, which is at the very heart of session types (as communication occurs, a session type must transition through each of its stages exactly once). As a result, extra work is required to simulate the linearity of the terms in the object language.

The present work simulates linearity by defining it as an inductive predicate on processes (\S \ref{linearity}). Once such a predicate establishes that a process uses channels linearly, the use of channels according to their specification is guaranteed by construction. References to both channels and messages are lifted into the host language, making the resulting syntax amicable to the user. As a consequence of this approach the object language requires \emph{no typing contexts} and \emph{no substitution lemmas}.

Other approaches to formalising process calculi are briefly exposed in \S \ref{related-work}. Closing, \S \ref{conclusion} suggests future work that might be of interest, and offers conclusions on what this project has achieved.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Background}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\picalc}\label{pi-calculus}

\paragraph{Scope} This section provides an overview of the \picalc{} as introduced in \cite{Sangiorgi2001}. However, it deliberately ignores replication and indeterministic choice, features part of the \picalc{} that are not covered by this project. Additionally, and as preliminary preparation for the introduction of session types, this section defines channel restriction by introducing two channel \emph{endpoints}, instead of the usual single variable used for channels. \todo{polarity}

The \picalc{} \cite{Walker1989,Milner1989,Milner1991,Sangiorgi2001} models processes that progress and change their structure by using \emph{channels} to communicate with one another. The \picalc{} features \emph{channel mobility}, which allows channels to be sent over channels themselves. In the \picalc{} any number of processes can communicate over a channel. While the \picalc{} can be typed, the type of a channel does \emph{not} evolve as communication occurs: it only specifies the type of data sent over it. An overview of the FAQs can be found in \cite{Wing2002}.

The syntax of the \picalc{} is given by the grammar in Figure \ref{picalc-syntax}. Inaction denotes the end of a process, and has therefore no continuation. Scope restriction creates a new communication channel between endpoints $x$ and $y$, which are bound in $P$. Output sends $u$ over the channel endpoint $x$, and then continues as $P$. Input waits to receive $u$ on the endpoint $y$; upon reception $u$ is bound in $P$. Selection sends the choice of process $l_j$ over $x$, and then continues as $P$. Branching offers choices over $I$, where the choice $l_i$ selects the continuation process $P_i$. Parallel composition runs processes $P$ and $Q$ in parallel, allowing these processes to communicate over shared channels.

\begin{figure}[H]
    \begin{align*}
    P,Q ::= \; &\PO                      & \text{inaction}             \\
               &\new{x}{y}P              & \text{scope restriction}    \\
               &\cout{x}{u}P             & \text{output}               \\
               &\cin{y}{u}P              & \text{input}                \\
               &\select{x}{l_j}P         & \text{selection}            \\
               &\branch{x}
               {\{l_i : P_i\}_{i \in I}} & \text{branching}            \\
               &\comp{P}{Q}              & \text{parallel composition}
    \end{align*}
    \caption{Grammar describing the syntax of the \picalc{}}
    \label{picalc-syntax}
\end{figure}

The syntax of the \picalc{} captures undesired syntactical properties of processes (e.g. associativity should not matter when three processes are composed in parallel). Structural congruence is introduced as a way to abstract over these unintended differences in syntax. It is defined by the smallest congruent equivalence relation that satisfies the inference rules in Figure \ref{picalc-congruence} -- a congruent equivalence relation in itself is the smallest relation that is reflexive, symmetric, transitive and congruent. Worth noting is the structural congruence rule for scope expansion: the scope of bound variables can include or exclude a process at will, as long as the bound variables do not appear free in that process. The congruence rule states that if two processes considered equal are placed within a common context, then the resulting contexts are equal as well (a context is a process where some occurrence of $\PO$ is substituted by a \emph{hole} that can then be filled in with a process). Said otherwise, structural congruence \emph{goes under} the syntactic constructs of the \picalc{}.

\begin{figure}[H]
    \begin{mathpar}
    \inferrule
        { }
        {\comp{P}{Q} \equiv \comp{Q}{P}}
        \quad (\textsc{C-CompComm})

    \inferrule
        { }
        {\new{x}{y} \new{z}{w} P \equiv \new{z}{w} \new{x}{y} P}
        \quad (\textsc{C-ScopeComm})

    \inferrule
        { }
        {\comp{P}{\PO} \equiv P}
        \quad (\textsc{C-Comp0})

    \inferrule
        { }
        {\comp {(\comp{P}{Q})} {R} \equiv \comp {P} {(\comp{Q}{R})}}
        \quad (\textsc{C-CompAssoc})

    \inferrule
        { }
        {\new{x}{y} \PO \equiv \PO}
        \quad (\textsc{C-Scope0})

    \inferrule
        { }
        {\new{x}{y}P \equiv \new{y}{x}P}
        \quad (\textsc{C-ScopeSwap})

    \inferrule
        {x,y \not\in fn(Q)}
        {\comp {(\new{x}{y}P)} {Q} \equiv \new{x}{y} \comp{P}{Q}}
        \quad (\textsc{C-ScopeExp})

    \end{mathpar}
    \caption{Structural congruence rules for the \picalc{}}
    \label{picalc-congruence}
\end{figure}

The operational semantics of the \picalc{} is specified by reduction rules, defined in Figure \ref{picalc-reduction}. Two parallel processes communicating over the same channel (by using opposite endpoints to send and receive a message) get reduced to the parallel composition of their continuations, with the continuation of the receiving process having all the references to the message substituted by the message term itself (\textsc{R-Comm}). Similarly, a process that makes a choice put in parallel with a process that offers a choice gets reduced to the continuation of the choosing process and the chosen continuation of the process offering the choice -- so long as the choice itself is valid (\textsc{R-Case}). Reduction goes under both restriction (\textsc{R-Res}) and parallel composition (\textsc{R-Par}), but not under output, input, selection or branching -- constructs that impose order in the communication. Lastly, reduction is defined up to structural congruence: any amount of syntax rewriting can be performed before and after reduction  (\textsc{R-Struct}).

\begin{figure}[H]
    \begin{mathpar}
    \inferrule 
        { }
        {\new{x}{y}(\comp {\cout{x}{a}P} {\cin{y}{b}Q}) \reduce
         \new{x}{y}(\comp {P}            {\subst{Q}{a}{b}})}
        \quad (\textsc{R-Comm})

    \inferrule
        {j \in I}
        {\new{x}{y}(\comp {\select{x}{l_j}P} {\branch{y}{\{l_i : Q_i\}_{i \in I}}}) \reduce
         \new{x}{y}(\comp {P} {Q_j})}
        \quad (\textsc{R-Case})

    \inferrule
        {P \reduce Q}
        {\new{x}{y}P \reduce \new{x}{y}Q}
        \quad (\textsc{R-Res})

    \inferrule
        {P \reduce Q}
        {\comp{P}{R} \reduce \comp{Q}{R}}
        \quad (\textsc{R-Par})

    \inferrule
        {P \equiv P' \\ P' \reduce Q' \\ Q' \equiv Q}
        {P \reduce Q}
        \quad (\textsc{R-Struct})
    \end{mathpar}
    \caption{Reduction rules for the \picalc{}}
    \label{picalc-reduction}
\end{figure}

As an example, Figure \ref{picalc-example} creates two linked channel endpoints $x$ and $y$ and then composes two processes in parallel: one that uses $x$ to send integers $3$ and $4$, and then expect a response bound as $r$, do some $P$, then end; another that uses $y$ to receive $a$ and $b$, then send $a+b$, then end. Both processes communicate with one another when composed in parallel, changing their structure.

\begin{figure}[H]
    \begin{align*}
    \new{x}{y} (\comp{\cout{x}{3} \cout{x}{4} \cin{x}{r} P. \PO &}
                     {\cin{y}{a} \cin{y}{b} \cout{y}{a+b} \PO})
    \reduce
    \\
    \new{x}{y} (\comp{\cout{x}{4} \cin{x}{r} P. \PO &}
                     {\cin{y}{b} \cout{y}{3+b} \PO})
    \reduce
    \\
    \new{x}{y} (\comp{\cin{x}{r} P. \PO &}
                     {\cout{y}{3+4} \PO})
    \reduce
    \\
    \new{x}{y} (\comp{\subst{P}{3+4}{r}. \PO &}
                     {\PO})
    \equiv
    \\
    \subst{P}{3&+4}{r}
    \end{align*}
    \caption{Example process in the \picalc{}}
    \label{picalc-example}
\end{figure}

The grammar for the \picalc{} allows well-formed processes with no semantic meaning (e.g. $\new{x}{y} \comp {\cout{x}{true}\PO} {\cin{y}{u}(u+3).\PO}$). The syntax rules for the construction of \picalc{} terms can be refined to discard some of these constructs. One such refinement are shared types (Figure \ref{picalc-shared-types}), which ensure that the types of channels and messages match -- in the example in Figure \ref{picalc-example}, channel endpoints $x$ and $y$ would need to be of the shared base type \type{Int} for the processes to be well-typed. The formation of \picalc{} terms can be further restricted with \emph{session types}: types that serve to specify communication protocols.

\begin{figure}[H]
    \begin{align*}
    T ::= \; &\type{Chan}[T] & \text{channel type} \\
             &\ldots         & \text{base type}
    \end{align*}
    \caption{Shared types for the \picalc{}}
    \label{picalc-shared-types}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Session types}\label{session-types}

\paragraph{Scope} This section covers a subset of session types: the diadic (shared by two processes), finite (no replication or recursion), deterministic (no indeterministic choice), and synchronous session types.

Session types \cite{Honda1993, Takeuchi1994, Honda1998} encode sequences of actions, each action containing the type and the direction of the data exchanged.  Processes must use session-typed channels according to their specified protocol.  Instead of being shared and static, session types are linear, private to the communicating processes, and changing as communication occurs. A comprehensive introduction to session types can be found in \cite{Vasconcelos2009}, while answers to FAQs are compiled in \cite{Dezani-ciancaglini2010}.

The grammar of session types is listed in the Figure \ref{session-types-grammar}. Channel termination admits no continuation. For sending and receiving, the type of the transmitted data and the session type of the continuation are required. The types transmitted can either be base types or session types. Branching and selection both expect a set of session types which contains the continuation that will be chosen. In the example process introduced in Figure \ref{picalc-example}, the session type of $x$ is $\type{\Send{Int}\Send{Int}\Recv{Int}\End}$, while the one of $y$ is $\type{\Recv{Int}\Recv{Int}\Send{Int}\End}$

\begin{figure}[H]
    \begin{align*}
        S ::= \; &\type{End}                      & \text{termination} \\
                 &\Send{T}S                       & \text{send} \\
                 &\Recv{T}S                       & \text{receive} \\
                 &\Select \{l_i : S_i\}_{i \in I} & \text{select} \\
                 &\Branch \{l_i : S_i\}_{i \in I} & \text{branch} \\
                 \\
        T ::= \; &S      & \text{session type}\\
                 &\ldots & \text{base type}
    \end{align*}
    \caption{Grammar for session types}
    \label{session-types-grammar}
\end{figure}

Note that the session types of $x$ and $y$ must be \emph{dual}: when one channel sends a type \type{T}, the other must receive \type{T}, and then both must continue dually. The precise definition of duality is given in Figure \ref{session-types-duality}. Duality is one of the core principles of session types, as it guarantees \emph{communication safety}.

\begin{figure}[H]
    \begin{mathpar}
    \inferrule{}{\dual{\Send{T}S} = \Recv{T}\dual{S}}

    \inferrule{}{\dual{\Recv{T}S} = \Send{T}\dual{S}}

    \inferrule{}{
        \dual{\Branch \{l_i : S_i\}_{i \in I}} =
        \Select \{l_i : \dual{S_i}\}_{i \in I}}

    \inferrule{}{
        \dual{\Select\{l_i : S_i\}_{i \in I}} =
        \Branch \{l_i : \dual{S_i}\}_{i \in I}}

    \inferrule{}{\dual{\End} = \End}
    \end{mathpar}
    \caption{Duality on session types}
    \label{session-types-duality}
\end{figure}

Session-typed channels impose typing rules on the syntactical constructs of the \picalc{}: a process can perform an action on a channel only if that channel is capable of the action. The typing rules for processes using session typed channels are shown in Figure \ref{session-types-typing-rules}. The judgment $\Gamma \types P$ signifies that $P$ is well typed under the context $\Gamma$. Contexts are linear: their elements cannot be duplicated nor discarded. The disjoint union operator $\circ$ represents context split: every element in the context $\Gamma_1 \circ \Gamma_2$ must appear exactly once in one of $\Gamma_1$ or $\Gamma_2$, but not in both.

A process can be terminated if the only channel in context is a channel that is expecting to be terminated --- thus premature termination is avoided. Restriction creates two linked channel endpoints, where these endpoints are dual. Parallel composition splits the linear context in two. Input requires a channel capable of receiving and a continuation process typed under the continuation channel and the received input --- context is split between those two. Output requires a channel capable of sending, a value to be sent, and a continuation process typed under the continuation channel --- context is split between those three. Selection requires a channel capable of selecting, a process typed under the internally selected continuation channel, and a valid selection —-- context is split between the first two. Branching requires a channel capable of branching, and for every possible external choice, a process typed under the externally chosen continuation channel --- context is split between the two.

\begin{figure}[H]
    \begin{mathpar}
    \inferrule
        { }
        {x : \type{End} \types \PO}
        \quad (\textsc{T-Inact})

    \inferrule
        {\Gamma,x:T,y:\dual{T} \types P}
        {\Gamma \types \new{x}{y}P}
        \quad (\textsc{T-Res})

    \inferrule
        {\Gamma_1 \types P \\
         \Gamma_2 \types Q}
        {\Gamma_1 \circ \Gamma_2 \types \comp{P}{Q}}
        \quad (\textsc{T-Par})

    \inferrule
        {\Gamma_1 \types x:\Recv{T}S \\
         \Gamma_2,x:S,y:T \types P}
        {\Gamma_1 \circ \Gamma_2 \types \cin{x}{y}P}
        \quad (\textsc{T-In})

    \inferrule
        {\Gamma_1 \types x:\Send{T}S \\
         \Gamma_2 \types v:T \\
         \Gamma_3,x:S \types P}
        {\Gamma_1 \circ \Gamma_2 \circ \Gamma_3 \types \cout{x}{v}P}
        \quad (\textsc{T-Out})

    \inferrule
        {\Gamma_1 \types x:\Select{\{l_i : S_i\}_{i \in I}} \\
         \Gamma_2,x:S_i \types P_i \\
         \exists j \in I}
        {\Gamma_1 \circ \Gamma_2 \types \select{x}{l_j}P}
        \quad (\textsc{T-Select})

    \inferrule
        {\Gamma_1 \types x:\Branch{\{l_i : S_i\}_{i \in I}} \\
         \Gamma_2,x:S_i \types P_i \\
         \forall i \in I}
        {\Gamma_1 \circ \Gamma_2 \types \branch{x}{\{l_i : P_i\}_{i \in I}}}
        \quad (\textsc{T-Branch})

    \end{mathpar}
    \caption{Typing rules for processes using session typed channels}
    \label{session-types-typing-rules}
\end{figure}

The reduction of session types is a byproduct of these rules, and follows the operational semantics of the \picalc{} listed in Figure \ref{picalc-reduction}: when two processes either communicate (\textsc{R-Comm}) or make a choice (\textsc{R-Case}) over linked dual channel endpoints, the \emph{head} of those channel endpoints (their first action) is consumed.

As a result of this setup, session types guarantee three properties:
\begin{description}
    \item [Communication privacy] Every channel endpoint is used exactly by one process. This applies to channels created by message input as well as by scope restriction. This property is a byproduct of the \textbf{linearity} of contexts: parallel composition splits the linear context into two disjoint unions, effectively deciding which process gets to use the endpoint.
        
    \item [Communication safety] Values sent by one process are expected by the process on the other side of the channel. This property arises as a result of \textbf{duality}: only processes that communicate over channel endpoints linked through restriction can be reduced, and restriction requires channel endpoints to have dual session types.

    \item [Session fidelity] Processes follow session types sequentially. This property is a consequence of linearity and the way in which the typing rules in Figure \ref{session-types-typing-rules} deconstruct session types by taking their continuations apart.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Coq proof assistant}\label{coq}

Coq \cite{CoqDeveloperCommunity} is a popular proof assistant and dependently typed functional language based on the calculus of inductive constructions \cite{Coquand1989} (which adds inductive data types to the calculus of constructions \cite{Coquand1985}), a type theory isomorphic to intuitionistic predicate calculus --- a constructive logic with quantified statements.  Coq features proof irrelevance for proofs (in \type{Prop}) and a cumulative set of universes (in \type{Type}).

The following example introduces some of the basic building blocks of dependent type programming. The type $\type{Zero}$ (also known as $\bot$) has no constructors: there exist no programs that inhabit it. The proposition $\type{P} \rightarrow \type{Zero}$ represents negation, that $\type{P}$ is provably false. Conversely, from a proof of falsity one might conclude anything: $\type{Zero} \rightarrow \type{P}$, for any $\type{P}$. The dual of $\bot$ is $\top$, here represented as $\type{One}$: the trivial type that contains no information. Sigma is the existential type, or dependent tuple: for some $A$ and some predicate $P$, the first element of the tuple is an $A$; the second element of the tuple is a proof that $P$ holds for that particular $A$.

\begin{coq}
    Inductive Zero : Type :=.
    Definition neg (P : Type) : Type := P -> Zero.
    Inductive One : Type := tt.

    Inductive Sig (A : Type) (P : A -> Type) : Type :=
      sig : forall (a : A), P a -> Sig A P.
    Arguments sig {A P}.
\end{coq}

Coq is dependently typed: types can depend on --- or even contain --- programs. Since that is the case, programs in Coq must exhibit termination --- recursion must occur on structurally smaller terms. The example bellow introduces the recursive function $\type{Even}$, which given a natural number returns a type --- that is to say, it relates each natural number with a proposition, in these case capturing their evenness. Below it, a proof that uses sigma types to show that there is at least one natural number that is even.

\begin{coq}
    Fixpoint Even (n : nat) : Type :=
      match n with
      | Z => One
      | (S Z) => Zero
      | (S (S n)) => Even n
      end.

    Example _ : Sig nat Even := sig 42 tt.
\end{coq}

Coq allows users to build proofs using \emph{tactics}: programs written in $L_{tac}$ that manipulate hypotheses and transform goals. While these programs might be incorrect, or not terminate, their outcome is ultimately checked by \emph{Gallina}, the specification language of Coq. The next example proves for every natural number $n$ that if $n$ is even, then $n+1$ is not. It does so by induction on $n$: the proof obligation in the base case reduces to $\neg \type{Even (S Z)}$, which by definition of $\text{Even}$ reduces to $\neg \type{Zero}$, that is, $\type{Zero} \rightarrow \type{Zero}$, the identity function. The inductive step is provable thanks to the fact that $\type{Even (S (S n))}$ reduces to $\type{Even n}$.

\begin{coq}
    Lemma SEven0 (n : nat) : Even n -> neg (Even (S n)).
    Proof.
      intros En ESn.
      induction n.
      contradiction.
      apply (IHn ESn En).
    Qed.
\end{coq}

In Coq, simultaneously pattern matching on multiple indexed data types can be extremely clunky and arduous. The \emph{Equations} package eases this inconvenience by enabling an equational definition style, pattern matching on the left, and \texttt{with} constructs (\cite{McBride2004}), making Coq as convenient for dependent pattern matching as Agda. The theorem $\type{SEven0}$ is proven again here, this time using dependent pattern matching. Coq is able to use tactics to solve the base case automatically, as $\type{ESn}$ is uninhabited.

\begin{coq}
    From Equations Require Import Equations.

    Equations SEven1 (n : nat) : Even n -> neg (Even (S n)) := {
    SEven1 Z En ESn := _ ;
    SEven1 (S n) En ESn := SEven1 n ESn En}.
\end{coq}

Coq supports inductive and coinductive data types,
\todo{indexed families of types}

\begin{coq}
    Inductive lte : nat -> nat -> Type :=
    | zlte : forall {n}, lte Z n
    | slte : forall {n m}, lte n m -> lte (S n) (S m)
    .

    Inductive Vec (A : Type) : nat -> Type :=
    | nil : Vec A Z
    | cons : forall {n}, A -> Vec A n -> Vec A (S n)
    .
\end{coq}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Polymorphism}\label{polymorphism}

Polymorphism allows programs to depend on types. If those types are unconstrained --- if the universe of types is infinite --- then programs are unable pattern match on them (as they cannot possibly produce infinitely many cases) and unable to create terms inhabiting them. Such unconstrained polymorphic types are said to be \emph{opaque}. Programs depending on opaque types exhibit common general properties that are highlighted in \cite{Wadler1989}. This project makes use of polymorphism to prevent the creation and inspection of terms of a polymorphic type.

\todo{more? should we move it into design?}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Design}\label{design}

\todo{Limit ourselves to channels with session types, no \#T}
\todo{Limit ourselves to linear types: $\circ$ is union of non intersecting sets}

This chapter covers the high-level design of the encoding of the session-typed \picalc{} into Coq. \todo{The main goal is using function abstraction}

Other efforts in formalising session types in Coq have created object languages and handled variable references, typing contexts, and typing judgments by hand \cite{Dilmore2019}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview}\label{overview}



Central to computing session-typed \picalc is the need to handle the state transitions of session types. One approach is \emph{continuation passing}, introduced in \S \ref{continuation-passing}, which destroys channels and creates new ones as part of every action of a process \cite{Dardha2016}. While there exist other approaches \todo{citation needed}, they all require for every state a session type is in to be used exactly once, i.e. linearity, discussed in \S \ref{linearity}.

\todo{mention the prize to pay}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Continuation passing}\label{continuation-passing}

\cite{Vasconcelos2010}
\todo{We merge pi calculus and session types into one}


Assuming linearity, \textbf{processes are correct by construction}: the processes that can be constructed depend on the session types of the channels in the environment of the host language; an action strips off the outer layer of a channel's session type --- modelling \textbf{continuation passing}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Linearity}\label{linearity}

\cite{Kobayashi1999}
\cite{Toninho2011}

One approach to simulating linearity is traversing processes \emph{a posteriori}, after they have been defined, to check that each channel is used exactly once. This can be done by making the type of channels parametric, and then instantiating it to $\mathbb{B}$ and \emph{marking} each channel for inspection. This allows both channel creation and message input to be modelled as function abstraction --- channels of a parametric type cannot be forged.  However, to be able to traverse processes where message passing is modelled as function abstraction, one has to be able to create all types of messages. To elude this problem, message types can be parametrised over a $\mathrm{Type} \rightarrow \mathrm{Type}$ function and then projected to the unit type.
    
Unfortunately, the approach in point (i) makes it impossible for processes to use any logic that is external to the calculus and depends on the type of messages. An alternative approach for simulating linearity is by doing it \emph{a priori}, at construction time, by keeping track of the linearly available channels through a context by which processes are indexed.  This means that channel creation cannot be represented through function abstraction, that process composition needs to explicitly split the context, and that there must be a way of addressing a particular channel within a context --- strings with the Barendregt convention \cite{Barendregt1984}, De Bruijn indices \cite{deBruijn1972}, locally nameless De Bruijn indices, or a parametric HOAS \cite{Chlipala2008} --- since only channels need to be used linearly, message input can still be represented as function abstraction whenever the message does not contain a channel. On the bright side, this approach allows processes to use logic that external to the calculus and depends on the types of messages.

While the latter approach has more appealing properties, its mechanics negatively affect usability: can it be equipped with the usability of the former approach? I intend to create a Coq library that abstracts away the simulation of linearity.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Parametric HOAS}\label{phoas}

\cite{Wadler1989}
\cite{Chlipala2008}
\todo{We use polymorphism to make channels opaque}
\todo{We do not do open processes}
\todo{We use polymorphism on messages to make processes traversable}

The introduction of both channels and received messages is modelled as function abstraction in Coq, therefore \textbf{variables are handled transparently} -- no substitution related lemmas are required. Channel types are parametrised to make them opaque -- they cannot be illicitly created or inspected by the user.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Subject reduction}\label{subject-reduction}

Ensuring that linearity is preserved through reduction is therefore essential:
\begin{theorem}
    $lin(P) \Rightarrow P \rightarrow Q \Rightarrow lin(Q).$
\end{theorem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation}\label{implementation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Session types}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Messages and processes}\label{processes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Linearity check}\label{linearity-check}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Linearity preservation}\label{linearity-preservation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Examples}\label{examples}

\todo{Type inference}
\begin{coq}
Example example1 : PProcess.
  refine
  ([v]> (new i <- _, o <- _, _)
    (i?[m]; ![m]; $\epsilon$) <|> (o![v _ true]; ?[m]; $\epsilon$)).
  auto.
Defined.
Print example1.

Example example2 : PProcess :=
  ([v]> (new o <- ! B[bool] ; ? B[bool] ; ø, i <- ? B[bool] ; ! B[bool] ; ø, ltac:(auto))
    (o![v _ true]; ?[m]; $\epsilon$) <|> i?[m]; ![m]; $\epsilon$).

Example congruent_example1 : example1 $\equiv$ example2. auto. Qed.

Example example3 : PProcess :=
  ([v]> (new o <- ? B[bool] ; ø, i <- ! B[bool] ; ø, ltac:(auto))
    (o?[m]; $\epsilon$) <|> i![v _ true]; $\epsilon$).

Example reduction_example1 : example2 => example3. auto. Qed.

Example subject_reduction_example1 : example2 => example3 -> Linear example2 -> Linear example3.
eauto.
Qed.

Example example4 : PProcess :=
  ([v]> (new i <- ! B[bool] ; ø, o <- ? B[bool] ; ø, ltac:(auto))
    (i![v _ true]; $\epsilon$ <|> o?[m]; $\epsilon$)).

Example congruent_example2 : example3 $\equiv$ example4. auto. Qed.

Example example5 : PProcess :=
  ([v]> (new i <- ø, o <- ø, Ends) ($\epsilon$ i <|> $\epsilon$ o)).

Example reduction_example2 : example4 => example5. auto. Qed.

Example big_step_reduction : example1 =>* example5. auto. Qed.

Example big_step_subject_reduction_example1
  : example1 =>* example5 -> Linear example1 -> Linear example5.
eauto.
Qed.

Example channel_over_channel : PProcess :=
  [v]>
    (new i <- ? C[ ! B[bool] ; ø ] ; ø, o <- ! C[ ! B[bool] ; ø ] ; ø, MLeft Ends)
    (new i' <- ? B[bool] ; ø, o' <- _, MLeft Ends)

    (i?[c]; fun a => $\epsilon$ a <|> c![v _ true]; $\epsilon$)
    <|>
    (o![o']; fun a => $\epsilon$ a <|> i'?[_]; $\epsilon$)
.

Example channel_over_channel1 : PProcess :=
  [v]>
    (new i' <- ? B[bool] ; ø, o' <- ! B[bool] ; ø, MLeft Ends)
    (new i <- ? C[ ! B[bool] ; ø ] ; ø, o <- ! C[ ! B[bool] ; ø ] ; ø, MLeft Ends)

    (i?[c]; fun a => c![v _ true]; $\epsilon$ <|> $\epsilon$ a)
    <|>
    (o![o']; fun a => i'?[_]; $\epsilon$ <|> $\epsilon$ a)
.

Example congruent_example3 : channel_over_channel $\equiv$ channel_over_channel1. auto. Qed.

Example nonlinear_example : PProcess :=
  [v]> (new i <- ? B[bool] ; ø, o <- ! B[bool] ; ø, MLeft Ends)

    (* Cheat the system by using the channel o twice *)
    i?[_]; $\epsilon$ <|> o![v _ true]; (fun _ => o![v _ true]; $\epsilon$)
    .

Example linear_example1 : Linear example1. auto. Qed.

Example linear_channel_over_channel : Linear channel_over_channel. auto. Qed.

Example nonlinear_example1 : ~ (Linear nonlinear_example). auto. Qed.

Example branch_and_select : PProcess :=
  ([v]> (new
           i <- &{ (! B[bool] ; ø) :: (? B[bool] ; ø) :: [] },
           o <- $\oplus${ (? B[bool] ; ø) :: (! B[bool] ; ø) :: [] },
           ltac:(auto))
          i$\triangleright${(![v _ true]; $\epsilon$) ; (?[m]; $\epsilon$)} <|> o$\triangleleft$Fin.F1; ?[_]; $\epsilon$).
\end{coq}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Related work}\label{related-work}

Linearity is strongly connected to session types: a session type must transition through each of its stages \emph{exactly} once. Session types can be encoded into a \picalc{} with linear types, as shown by \cite{Kobayashi1996,Dardha2012,Dardha2016}. As shown in \cite{Voinea}, in systems where session types are shared, the tokens allowing access to the session-typed channels must still be linear.

The connection between session types and linearity can be drawn even further, at the logical level, where an isomorphism between linear logic and session types can be shown \cite{Caires2010} \cite{Wadler2014}. In \cite{Lindley2015} the operational semantics for a session-typed functional language that builds on Wadler's isomorphism are given. This work is continued in \cite{Lindley}, where the language is extended with polymorphism, row types, subkinding, and non-linear data types. \cite{Gay2010} uses a linear type-system to encode asynchronous session types with buffers --- and then verify properties of those buffers.

In type systems with no linear types the linearity of channels has to be simulated. In these type systems, modelling channels through a parametric higher order abstract syntax \cite{Chlipala2008} is not possible per se: the host language is unable to check whether the channels passed along as arguments are used linearly. This means that typing judgments must happen at the object language, through the use of a context that keeps track of linear resources.  This context is usually tracked at the type level, using inductive \emph{families} \cite{Dybjer1994} indexed by a context of linear resources \cite{Power2000} --- though there are approaches that keep track of context through type-classes and use monadic binding to embed a linear calculus within non-linear hosts \cite{Paykin2017}.

The \picalc{} has been an extensive subject of machine verification: \cite{Henry-Gerard1999} proofs subject reduction for it; \cite{Despeyroux2000} proofs subject reduction as well, but uses a higher order syntax; \cite{Affeldt2008} provides proofs of fairness and confluence; \cite{Honsell2001} formalises the bisimilarity proofs found in \cite{Walker1989}; \cite{Gay2001} provides a framework for formalisation on the \picalc{} with linear channels in Isabelle/HOL.

In \cite{Xi2016} session types are formalised in ATS, providing type preservation and global progress proofs. \cite{Bock2016} uses Celf to represent session types in intuitionistic linear logic.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}\label{conclusion}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{alpha}
\bibliography{mproj}
\end{document}
