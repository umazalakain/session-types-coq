\documentclass{mproj}

\usepackage[utf8]{inputenc}

% Coq code
\usepackage[dvipsnames]{xcolor}
\usepackage{listingsutf8}
\input{lstcoq.sty}

% Math
\usepackage{amsmath}
\usepackage{amssymb}

% Use times font
\usepackage{times}

% They are all over the place
\usepackage{todonotes}

% Allows to place figures HERE!
\usepackage{float}

% Enums
\usepackage[inline]{enumitem}
\setlist{nolistsep}

% Inference rules
\usepackage{mathpartir}

% Links and their colors
\usepackage{url}
\usepackage[
  colorlinks=true,
  linkcolor=darkgray,
  citecolor=darkgray,
  urlcolor=darkgray,
  ]{hyperref}

\usepackage{titlesec}
% Use a single line for chapter headers
\titleformat{\chapter}[hang]{\normalfont\huge\bfseries}{\thechapter.}{1em}{} 
% Remove the space before chapter titles
\titlespacing*{\chapter}{0pt}{0pt}{40pt}

% Appendices
\usepackage[header,title,titletoc]{appendix}
\renewcommand{\appendixname}{Appendix}

% License
\usepackage[
    type={CC},
    modifier={by-sa},
    version={3.0},
]{doclicense}

\usepackage[many]{tcolorbox}
\newtcolorbox{thesis-statement}[1]{%
    tikznode boxed title,
    enhanced,
    arc=0mm,
    interior style={white},
    attach boxed title to top center= {yshift=-\tcboxedtitleheight/2},
    fonttitle=\bfseries,
    colbacktitle=white,coltitle=black,
    boxed title style={size=normal,colframe=white,boxrule=0pt},
    title={#1}}

% Add bibliography to TOC
\usepackage[nottoc,numbib]{tocbibind}

% Switch off page numbering for noe
\pagenumbering{gobble}


\newtheorem{theorem}{Theorem}

% Commands for the pi-calculus
\newcommand{\PO}{\mathbf{0}}
\newcommand{\comp}[2]{#1 \mid #2}
\newcommand{\new}[2]{(\boldsymbol{\nu} #1 #2) \;}
\newcommand{\cout}[2]{\overline{#1}\langle#2\rangle.}
\newcommand{\cin}[2]{#1(#2).}
\newcommand{\select}[2]{#1\triangleleft#2.}
\newcommand{\branch}[2]{#1\triangleright#2}
\newcommand{\subst}[3]{#1[#2/#3]}
\newcommand{\picalc}{$\pi$-calculus}
\newcommand{\Picalc}{$\pi$-Calculus}
\newcommand{\type}{\texttt}
\newcommand{\End}{\type{End}}
\newcommand{\Send}[1]{!#1.}
\newcommand{\Recv}[1]{?#1.}
\newcommand{\Select}{\oplus}
\newcommand{\Branch}{\&}
\newcommand{\dual}{\overline}
\newcommand{\reduce}{\rightarrow}
\renewcommand{\emptyset}{\varnothing}
\newcommand{\types}{\vdash}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Type-checking\\ session-typed \picalc \\ with Coq}
\author{Uma Zalakain}
\date{2019-09-06}
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
\todo{go over this again}
    This project formalises the session-typed \picalc{} in Coq using a mix of continuation passing, parametric HOAS, dependent types and ad-hoc linearity checks. Each action a process takes requires a channel capable of that action. The head of that channel's type is then stripped off and its continuation is passed to the next action the process takes. Dependent types guarantee this continuation passing is correct by construction. The type of channels is parametrised over, so that users are unable to skip the proper mechanisms to create channels. The HOAS makes the syntax easy to use for both the end user and the designer: all variables are lifted to Coq, no typing contexts are required. The continuation passing always creates channels that must be used exactly once, but unfortunately Coq has no support for linearity, so this check needs to happen ad-hoc, by traversing processes. Ultimately, the claim is this: if the definition of a process typechecks in Coq, and the process uses channels linearly, then type safety and type preservation through reduction hold.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\educationalconsent
\vfill{}
\doclicenseThis
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgements}

Acknowledgements go here

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}\label{intro}
% Start page numbering here
\pagenumbering{arabic}

During the last decades, while the frequency at which processors run has peaked, the number of available processing units has kept growing. Computing has consequently shifted its focus into making processes safely communicate with one another --- no matter if they run concurrently on different CPU cores or on different hosts. The interest in the formalisation and verification of \emph{communicating concurrent} systems (where processes share no state and change as communication occurs) has grown as a result.

Communicating concurrent processes must satisfy some safety properties, such as following a pre-established communication protocol (where all messages sent by one process are expected by the other and vice versa) or communicating over private channels only known to the involved participants. To make properties like these easier to prove, formal models such as the \emph{\picalc{}} \cite{Walker1989,Milner1989,Milner1991,Sangiorgi2001} abstract real-world systems into suitable mathematical representations. \S \ref{pi-calculus} provides a brief overview of the \picalc.

The properties of a formal system can be verified either \emph{dynamically}, by monitoring processes at runtime, or \emph{statically}, by reasoning on the definition of the processes themselves.  Static guarantees --- while harder to define and sometimes more conservative than dynamic ones --- are \emph{total}, and thus satisfied regardless of the execution path. The basis of static verification is comprised of \emph{types} and \emph{type systems}, which are also the basis of programming languages and tools, making type-based verification techniques transferable to practical applications. An example of this are the plethora of types for communication and process calculi: from standard channel types, as found in e.g., Erlang or Go, to \emph{session types} \cite{Honda1993, Takeuchi1994, Honda1998}, a formalism used to specify and verify communication protocols (more in \S \ref{session-types}).

\todo{move session type definition and properties up here?}

The mechanised formalisation and verification of programming languages and calculi is an ongoing community effort in securing existing work: humans are able to check proofs, but they are very likely to make mistakes; machines can verify proofs mechanically. A remarkable example of a community effort towards machine verification is RustBelt \cite{Dreyer2018}, a project that aims to formalise and machine-check the ownership system of the programming language Rust with the help of separation logic \cite{} and the proof assistant Coq. Not only does mechanisation increase confidence in what is mechanised, but also in all other derived work that is yet unverified: proving the correctness of Rust's type system immediately increases the confidence in all software written in it.

\todo{make this short, take it out of the box, just centered and in italics}
\begin{thesis-statement}{THESIS STATEMENT}
    This project formalises the \emph{session-typed \picalc{}} in such a way that variable references in the object language are lifted into variable references in the host language. The use of channels in the object language is then restricted to be linear, ensuring \emph{communication privacy}, \emph{communication safety} and \emph{session fidelity} (refer to \S \ref{session-types-properties}). Lastly, we machine-verify \emph{subject reduction} for the resulting language.
\end{thesis-statement}

\todo{mention we have no shared channels and no recursive session types}

We choose Coq \cite{Coquand1989, CoqDeveloperCommunity} to machine-verify the session-typed \picalc{}, mainly due to its widespread use as a proof assistant (refer to \S \ref{coq} for an overview). A first challenge with Coq is that it offers \emph{no} support for \emph{linearity}, which is at the very heart of session types (as communication occurs, a session type must transition through each of its stages exactly once). As a result, extra work is required to simulate the linearity of the terms in the object language.

The present work simulates linearity by defining it as an inductive predicate on processes (\S \ref{linearity}). Once such a predicate establishes that a process uses channels linearly, the use of channels according to their specification is guaranteed by construction. References to both channels and messages are lifted into the host language, making the resulting syntax amicable to the user. As a consequence of this approach the object language requires \emph{no typing contexts} and \emph{no substitution lemmas}.

Other approaches to formalising process calculi are briefly exposed in \S \ref{related-work}. Closing, \S \ref{conclusion} suggests future work that might be of interest, and offers conclusions on what this project has achieved.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Background}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\picalc}\label{pi-calculus}

\paragraph{Scope} This section provides an overview of the \picalc{} as introduced in \cite{Sangiorgi2001}. However, it deliberately ignores replication and indeterministic choice, features part of the \picalc{} that are not covered by this project. Additionally, and as preliminary preparation for the introduction of session types, this section defines channel restriction by introducing two channel \emph{endpoints}, instead of the usual single variable used for channels. \todo{polarity}

The \picalc{} \cite{Walker1989,Milner1989,Milner1991,Sangiorgi2001} models processes that progress and change their structure by using \emph{channels} to communicate with one another. The \picalc{} features \emph{channel mobility}, which allows channels to be sent over channels themselves. In the \picalc{} any number of processes can communicate over a channel. While the \picalc{} can be typed, the type of a channel does \emph{not} evolve as communication occurs: it only specifies the type of data sent over it. An overview of the FAQs can be found in \cite{Wing2002}.

The syntax of the \picalc{} is given by the grammar in Figure \ref{picalc-syntax}. Inaction denotes the end of a process, and has therefore no continuation. Scope restriction creates a new communication channel between endpoints $x$ and $y$, which are bound in $P$. Output sends $u$ over the channel endpoint $x$, and then continues as $P$. Input waits to receive $u$ on the endpoint $y$; upon reception $u$ is bound in $P$. Selection sends the choice of process $l_j$ over $x$, and then continues as $P$. Branching offers choices over $I$, where the choice $l_i$ selects the continuation process $P_i$. Parallel composition runs processes $P$ and $Q$ in parallel, allowing these processes to communicate over shared channels.

\begin{figure}[H]
    \begin{align*}
    P,Q ::= \; &\PO                      & \text{inaction}             \\
               &\new{x}{y}P              & \text{scope restriction}    \\
               &\cout{x}{u}P             & \text{output}               \\
               &\cin{y}{u}P              & \text{input}                \\
               &\select{x}{l_j}P         & \text{selection}            \\
               &\branch{x}
               {\{l_i : P_i\}_{i \in I}} & \text{branching}            \\
               &\comp{P}{Q}              & \text{parallel composition}
    \end{align*}
    \caption{Grammar describing the syntax of the \picalc{}}
    \label{picalc-syntax}
\end{figure}

The syntax of the \picalc{} captures undesired syntactical properties of processes (e.g. associativity should not matter when three processes are composed in parallel). Structural congruence is introduced as a way to abstract over these unintended differences in syntax. It is defined by the smallest congruent equivalence relation that satisfies the inference rules in Figure \ref{picalc-congruence} -- a congruent equivalence relation in itself is the smallest relation that is reflexive, symmetric, transitive and congruent. Worth noting is the structural congruence rule for scope expansion: the scope of bound variables can include or exclude a process at will, as long as the bound variables do not appear free in that process. The congruence rule states that if two processes considered equal are placed within a common context, then the resulting contexts are equal as well (a context is a process where some occurrence of $\PO$ is substituted by a \emph{hole} that can then be filled in with a process). Said otherwise, structural congruence \emph{goes under} the syntactic constructs of the \picalc{}.

\begin{figure}[H]
    \begin{mathpar}
    \inferrule
        { }
        {\comp{P}{Q} \equiv \comp{Q}{P}}
        \quad (\textsc{C-CompComm})

    \inferrule
        { }
        {\new{x}{y} \new{z}{w} P \equiv \new{z}{w} \new{x}{y} P}
        \quad (\textsc{C-ScopeComm})

    \inferrule
        { }
        {\comp{P}{\PO} \equiv P}
        \quad (\textsc{C-Comp0})

    \inferrule
        { }
        {\comp {(\comp{P}{Q})} {R} \equiv \comp {P} {(\comp{Q}{R})}}
        \quad (\textsc{C-CompAssoc})

    \inferrule
        { }
        {\new{x}{y} \PO \equiv \PO}
        \quad (\textsc{C-Scope0})

    \inferrule
        { }
        {\new{x}{y}P \equiv \new{y}{x}P}
        \quad (\textsc{C-ScopeSwap})

    \inferrule
        {x,y \not\in fn(Q)}
        {\comp {(\new{x}{y}P)} {Q} \equiv \new{x}{y} \comp{P}{Q}}
        \quad (\textsc{C-ScopeExp})

    \end{mathpar}
    \caption{Structural congruence rules for the \picalc{}}
    \label{picalc-congruence}
\end{figure}

The operational semantics of the \picalc{} is specified by reduction rules, defined in Figure \ref{picalc-reduction}. Two parallel processes communicating over the same channel (by using opposite endpoints to send and receive a message) get reduced to the parallel composition of their continuations, with the continuation of the receiving process having all the references to the message substituted by the message term itself (\textsc{R-Comm}). Similarly, a process that makes a choice put in parallel with a process that offers a choice gets reduced to the continuation of the choosing process and the chosen continuation of the process offering the choice -- so long as the choice itself is valid (\textsc{R-Case}). Reduction goes under both restriction (\textsc{R-Res}) and parallel composition (\textsc{R-Par}), but not under output, input, selection or branching -- constructs that impose order in the communication. Lastly, reduction is defined up to structural congruence: any amount of syntax rewriting can be performed before and after reduction  (\textsc{R-Struct}).

\begin{figure}[H]
    \begin{mathpar}
    \inferrule 
        { }
        {\new{x}{y}(\comp {\cout{x}{a}P} {\cin{y}{b}Q}) \reduce
         \new{x}{y}(\comp {P}            {\subst{Q}{a}{b}})}
        \quad (\textsc{R-Comm})

    \inferrule
        {j \in I}
        {\new{x}{y}(\comp {\select{x}{l_j}P} {\branch{y}{\{l_i : Q_i\}_{i \in I}}}) \reduce
         \new{x}{y}(\comp {P} {Q_j})}
        \quad (\textsc{R-Case})

    \inferrule
        {P \reduce Q}
        {\new{x}{y}P \reduce \new{x}{y}Q}
        \quad (\textsc{R-Res})

    \inferrule
        {P \reduce Q}
        {\comp{P}{R} \reduce \comp{Q}{R}}
        \quad (\textsc{R-Par})

    \inferrule
        {P \equiv P' \\ P' \reduce Q' \\ Q' \equiv Q}
        {P \reduce Q}
        \quad (\textsc{R-Struct})
    \end{mathpar}
    \caption{Reduction rules for the \picalc{}}
    \label{picalc-reduction}
\end{figure}

As an example, Figure \ref{picalc-example} creates two linked channel endpoints $x$ and $y$ and then composes two processes in parallel: one that uses $x$ to send integers $3$ and $4$, and then expect a response bound as $r$, do some $P$, then end; another that uses $y$ to receive $a$ and $b$, then send $a+b$, then end. Both processes communicate with one another when composed in parallel, changing their structure.

\begin{figure}[H]
    \begin{align*}
    \new{x}{y} (\comp{\cout{x}{3} \cout{x}{4} \cin{x}{r} P. \PO &}
                     {\cin{y}{a} \cin{y}{b} \cout{y}{a+b} \PO})
    \reduce
    \\
    \new{x}{y} (\comp{\cout{x}{4} \cin{x}{r} P. \PO &}
                     {\cin{y}{b} \cout{y}{3+b} \PO})
    \reduce
    \\
    \new{x}{y} (\comp{\cin{x}{r} P. \PO &}
                     {\cout{y}{3+4} \PO})
    \reduce
    \\
    \new{x}{y} (\comp{\subst{P}{3+4}{r}. \PO &}
                     {\PO})
    \equiv
    \\
    \subst{P}{3&+4}{r}
    \end{align*}
    \caption{Example process in the \picalc{}}
    \label{picalc-example}
\end{figure}

The grammar for the \picalc{} allows well-formed processes with no semantic meaning (e.g. $\new{x}{y} \comp {\cout{x}{true}\PO} {\cin{y}{u}(u+3).\PO}$). The syntax rules for the construction of \picalc{} terms can be refined to discard some of these constructs. One such refinement are shared types (Figure \ref{picalc-shared-types}), which ensure that the types of channels and messages match -- in the example in Figure \ref{picalc-example}, channel endpoints $x$ and $y$ would need to be of the shared base type \type{Int} for the processes to be well-typed. The formation of \picalc{} terms can be further restricted with \emph{session types}: types that serve to specify communication protocols.

\begin{figure}[H]
    \begin{align*}
    T ::= \; &\type{Chan}[T] & \text{channel type} \\
             &\ldots         & \text{base type}
    \end{align*}
    \caption{Shared types for the \picalc{}}
    \label{picalc-shared-types}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Session types}\label{session-types}

\paragraph{Scope} This section covers a subset of session types: the diadic (shared by two processes), finite (no replication or recursion), deterministic (no indeterministic choice), and synchronous session types.

Session types \cite{Honda1993, Takeuchi1994, Honda1998} encode sequences of actions, each action containing the type and the direction of the data exchanged.  Processes must use session-typed channels according to their specified protocol.  Instead of being shared and static, session types are linear, private to the communicating processes, and changing as communication occurs. A comprehensive introduction to session types can be found in \cite{Vasconcelos2009}, while answers to FAQs are compiled in \cite{Dezani-ciancaglini2010}.

The grammar of session types is listed in the Figure \ref{session-types-grammar}. Channel termination admits no continuation. For sending and receiving, the type of the transmitted data and the session type of the continuation are required. The types transmitted can either be base types or session types. Branching and selection both expect a set of session types which contains the continuation that will be chosen. In the example process introduced in Figure \ref{picalc-example}, the session type of $x$ is $\type{\Send{Int}\Send{Int}\Recv{Int}\End}$, while the one of $y$ is $\type{\Recv{Int}\Recv{Int}\Send{Int}\End}$

\begin{figure}[H]
    \begin{align*}
        S ::= \; &\type{End}                      & \text{termination} \\
                 &\Send{T}S                       & \text{send} \\
                 &\Recv{T}S                       & \text{receive} \\
                 &\Select \{l_i : S_i\}_{i \in I} & \text{select} \\
                 &\Branch \{l_i : S_i\}_{i \in I} & \text{branch} \\
                 \\
        T ::= \; &S      & \text{session type}\\
                 &\ldots & \text{base type}
    \end{align*}
    \caption{Grammar for session types}
    \label{session-types-grammar}
\end{figure}

Note that the session types of $x$ and $y$ must be \emph{dual}: when one channel sends a type \type{T}, the other must receive \type{T}, and then both must continue dually. The precise definition of duality is given in Figure \ref{session-types-duality}. Duality is one of the core principles of session types, as it guarantees \emph{communication safety}.

\begin{figure}[H]
    \begin{mathpar}
    \inferrule{}{\dual{\Send{T}S} = \Recv{T}\dual{S}}

    \inferrule{}{\dual{\Recv{T}S} = \Send{T}\dual{S}}

    \inferrule{}{
        \dual{\Branch \{l_i : S_i\}_{i \in I}} =
        \Select \{l_i : \dual{S_i}\}_{i \in I}}

    \inferrule{}{
        \dual{\Select\{l_i : S_i\}_{i \in I}} =
        \Branch \{l_i : \dual{S_i}\}_{i \in I}}

    \inferrule{}{\dual{\End} = \End}
    \end{mathpar}
    \caption{Duality on session types}
    \label{session-types-duality}
\end{figure}

Session-typed channels impose typing rules on the syntactical constructs of the \picalc{}: a process can perform an action on a channel only if that channel is capable of the action. The typing rules for processes using session typed channels are shown in Figure \ref{session-types-typing-rules}. The judgment $\Gamma \types P$ signifies that $P$ is well typed under the context $\Gamma$. Contexts are linear: their elements cannot be duplicated nor discarded. The disjoint union operator $\circ$ represents context split: every element in the context $\Gamma_1 \circ \Gamma_2$ must appear exactly once in one of $\Gamma_1$ or $\Gamma_2$, but not in both.

A process can be terminated if the only channel in context is a channel that is expecting to be terminated --- thus premature termination is avoided. Restriction creates two linked channel endpoints, where these endpoints are dual. Parallel composition splits the linear context in two. Input requires a channel capable of receiving and a continuation process typed under the continuation channel and the received input --- context is split between those two. Output requires a channel capable of sending, a value to be sent, and a continuation process typed under the continuation channel --- context is split between those three. Selection requires a channel capable of selecting, a process typed under the internally selected continuation channel, and a valid selection —-- context is split between the first two. Branching requires a channel capable of branching, and for every possible external choice, a process typed under the externally chosen continuation channel --- context is split between the two.

\begin{figure}[H]
    \begin{mathpar}
    \inferrule
        { }
        {x : \type{End} \types \PO}
        \quad (\textsc{T-Inact})

    \inferrule
        {\Gamma,x:T,y:\dual{T} \types P}
        {\Gamma \types \new{x}{y}P}
        \quad (\textsc{T-Res})

    \inferrule
        {\Gamma_1 \types P \\
         \Gamma_2 \types Q}
        {\Gamma_1 \circ \Gamma_2 \types \comp{P}{Q}}
        \quad (\textsc{T-Par})

    \inferrule
        {\Gamma_1 \types x:\Recv{T}S \\
         \Gamma_2,x:S,y:T \types P}
        {\Gamma_1 \circ \Gamma_2 \types \cin{x}{y}P}
        \quad (\textsc{T-In})

    \inferrule
        {\Gamma_1 \types x:\Send{T}S \\
         \Gamma_2 \types v:T \\
         \Gamma_3,x:S \types P}
        {\Gamma_1 \circ \Gamma_2 \circ \Gamma_3 \types \cout{x}{v}P}
        \quad (\textsc{T-Out})

    \inferrule
        {\Gamma_1 \types x:\Select{\{l_i : S_i\}_{i \in I}} \\
         \Gamma_2,x:S_i \types P_i \\
         \exists j \in I}
        {\Gamma_1 \circ \Gamma_2 \types \select{x}{l_j}P}
        \quad (\textsc{T-Select})

    \inferrule
        {\Gamma_1 \types x:\Branch{\{l_i : S_i\}_{i \in I}} \\
         \Gamma_2,x:S_i \types P_i \\
         \forall i \in I}
        {\Gamma_1 \circ \Gamma_2 \types \branch{x}{\{l_i : P_i\}_{i \in I}}}
        \quad (\textsc{T-Branch})

    \end{mathpar}
    \caption{Typing rules for processes using session typed channels}
    \label{session-types-typing-rules}
\end{figure}

The reduction of session types is a byproduct of these rules, and follows the operational semantics of the \picalc{} listed in Figure \ref{picalc-reduction}: when two processes either communicate (\textsc{R-Comm}) or make a choice (\textsc{R-Case}) over linked dual channel endpoints, the \emph{head} of those channel endpoints (their first action) is consumed.

As a result of this setup, session types guarantee three properties:
\begin{description}
    \item [Communication privacy] Every channel endpoint is used exactly by one process. This applies to channels created by message input as well as by scope restriction. This property is a byproduct of the \textbf{linearity} of contexts: parallel composition splits the linear context into two disjoint unions, effectively deciding which process gets to use the endpoint.
        
    \item [Communication safety] Values sent by one process are expected by the process on the other side of the channel. This property arises as a result of \textbf{duality}: only processes that communicate over channel endpoints linked through restriction can be reduced, and restriction requires channel endpoints to have dual session types.

    \item [Session fidelity] Processes follow session types sequentially. This property is a consequence of linearity and the way in which the typing rules in Figure \ref{session-types-typing-rules} deconstruct session types by taking their continuations apart.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Coq proof assistant}\label{coq}

Coq \cite{CoqDeveloperCommunity} is a popular proof assistant and dependently typed functional language based on the calculus of inductive constructions \cite{Coquand1989} (which adds inductive data types to the calculus of constructions \cite{Coquand1985}), a type theory isomorphic to intuitionistic predicate calculus --- a constructive logic with quantified statements.  Coq features proof irrelevance for proofs (in \coqe{Prop}) and a cumulative set of universes (in \coqe{Type}).

The following example introduces some of the basic building blocks of dependent type programming. The type \coqe{Zero} (also known as $\bot$) has no constructors: there exist no programs that inhabit it. The proposition \coqe{P -> Zero} represents negation, that \coqe{P} is provably false. Conversely, from a proof of falsity one might conclude anything: \coqe{Zero -> P}, for any \coqe{P}. The dual of $\bot$ is $\top$, here represented as \coqe{One}: the trivial type that contains no information. Sigma is the existential type, or dependent tuple: for some $A$ and some predicate $P$, the first element of the tuple is an $A$; the second element of the tuple is a proof that $P$ holds for that particular $A$.

\begin{coq}
    Inductive Zero : Type :=.
    Definition neg (P : Type) : Type := P -> Zero.
    Inductive One : Type := tt.

    Inductive Sig (A : Type) (P : A -> Type) : Type :=
      sig : forall (a : A), P a -> Sig A P.
    Arguments sig {A P}.
\end{coq}

Coq is dependently typed: types can depend on --- or even contain --- programs. Since that is the case, programs in Coq must exhibit termination --- recursion must occur on structurally smaller terms. The example bellow introduces the recursive function \coqe{Even}, which given a natural number returns a type --- that is to say, it relates each natural number with a proposition, in these case capturing their evenness. Below it, a proof that uses sigma types to show that there is at least one natural number that is even.

\begin{coq}
    Fixpoint Even (n : nat) : Type :=
      match n with
      | Z         => One
      | (S Z)     => Zero
      | (S (S n)) => Even n
      end.

    Example _ : Sig nat Even := sig 42 tt.
\end{coq}

Coq allows users to build proofs using \emph{tactics}: programs written in $L_{tac}$ that manipulate hypotheses and transform goals. While these programs might be incorrect, or not terminate, their outcome is ultimately checked by \emph{Gallina}, the specification language of Coq. The example below proves for every natural number $n$ that if $n$ is even, then $n+1$ is not. It does so through the sequential application of tactics. Each tactic manipulates the goal and context of the proof (see annotations in comments). The proof proceeds by induction on $n$: the proof obligation in the base case reduces to \coqe{neg (Even (S Z))}, which by definition of \coqe{Even} reduces to \coqe{neg Zero}, that is, \coqe{Zero -> Zero}, the identity function. The inductive step is provable thanks to the fact that \coqe{Even (S (S n))} reduces to \coqe{Even n}.

\begin{coq}
    Lemma SEven0 (n : nat) : Even n -> neg (Even (S n)).
    Proof.
      (* n : nat
         --------------------
         Even n -> neg (Even (S n)) *)
      intros En ESn.

      (* n : nat 
         En : Even n
         ESn : Even (S n)
         --------------------
         Zero *)
      induction n.

      (* En : Even 0
         ESn : Even 1
         --------------------
         Zero *)
      contradiction.

      (* n : nat
         En : Even (S (S n))
         ESn : Even (S (S n))
         IHn : Even n -> Even (S n) -> Zero
         --------------------
         Zero *)
      apply (IHn ESn En).
    Qed.
\end{coq}

In Coq, simultaneously pattern matching on multiple indexed data types can be extremely clunky and arduous. The \emph{Equations} package eases this inconvenience by enabling an equational definition style, pattern matching on the left, and \texttt{with} constructs (\cite{McBride2004}), making Coq as convenient for dependent pattern matching as Agda. The theorem \coqe{SEven0} is proven again here, this time using dependent pattern matching. Coq is able to use tactics to solve the base case automatically, as \coqe{ESn} is uninhabited.

\begin{coq}
    From Equations Require Import Equations.

    Equations SEven1 (n : nat) : Even n -> neg (Even (S n)) := {
    SEven1 Z     En ESn := _ ;
    SEven1 (S n) En ESn := SEven1 n ESn En}.
\end{coq}

Coq supports inductive and coinductive data types,
\todo{indexed families of types}

\begin{coq}
    Inductive lte : nat -> nat -> Type :=
    | zlte : forall {n}, lte Z n
    | slte : forall {n m}, lte n m -> lte (S n) (S m)
    .

    Inductive Vec (A : Type) : nat -> Type :=
    | nil  : Vec A Z
    | cons : forall {n}, A -> Vec A n -> Vec A (S n)
    .
\end{coq}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Design}\label{design}

This chapter describes how we encode the session-typed \picalc{} into Coq. Our encoding only handles session-typed channels, specifically channels with finite (non-replicating, non-recursive) session types. The encoding has no intermediary models --- for instance, the polarised linear \picalc{}. The main characteristic of our design is the use of function abstraction to pass around both messages and channels (see \S \ref{overview}); alternative approaches are listed in \S \ref{alternative-encodings}. \todo{fixme}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview}\label{overview}

Our design is based on \emph{continuation passing}, where channels are \textbf{used exactly once}: channels get destroyed and created with every action taken by a process. This approach has its origin in the encoding of session types into the polarised linear \picalc{} \cite{Dardha2016, otherwork}: session-typed channels are transformed into single-use polarised channels, each containing the type of data being transmitted and the encoding of the channel's continuation. For instance, the session type $\Send{A} \Recv{B} \End$ is encoded as $\ell_o [A,\ell_i [B,\ell_\emptyset []]]$ where $\ell_i [A, Cont]$ is a single-use channel signifying input $A$, then continue as $Cont$ --- and similarly for output. When a process uses a channel with such a type to communicate, that channel gets destroyed, the \emph{head} of the channel's type is consumed, and a new channel with the \emph{tail} of the type ($\ell_i [B, \ell_\emptyset []]$) is created.

The main characteristic of our design is the use of a higher order abstract syntax as a way of passing around references to both messages and channels. That is, references are not modeled in the object language, but in the host language, in Coq. This approach offers several advantages, but it also creates several challenges that must be addressed:

\paragraph{Advantages}
\begin{enumerate}
    \item \emph{The user can refer naturally to both messages and channels}

    Our approach lifts all variable references into Coq. The example session-typed \picalc{} process bellow has two branches: one that outputs \coqe{true} and receives some \coqe{m}; the other that receives some \coqe{m} and outputs that same \coqe{m}. Note that \coqe{m} gets bound as a variable in Coq. Alternative approaches that encode variable references in the object language itself need to use de Bruijn indices \cite{deBruijn1972} or similar techniques, resulting in a processing overhead for users.
        
    \begin{coq}
    Example example2 : PProcess := ([v]>
        (new o <- ! B[bool] ; ? B[bool] ; ø,
             i <- ? B[bool] ; ! B[bool] ; ø,
             ltac:(auto))
        (o![v _ true]; ?[m]; $\epsilon$) <|> i?[m]; ![m]; $\epsilon$).
    \end{coq}

    \item \emph{There is no need for machinery that avoids variable capture}

    Explanation

    \item \emph{There is no need for substitution lemmas}

    Explanation
\end{enumerate}

\paragraph{Problems}
\begin{enumerate}
    \item \emph{Channels can be manufactured outside the calculus}

    The \picalc{} provides two ways to obtain a channel: by using scope restriction, and by receiving a message that contains a channel. The user must be restricted to use these constructs. If the type of channels is defined inductively, the user is not prevented from forging channels. Our solution to this problem is to parametrise processes with an unknown channel type, and to define our calculus and its theorems parametrised by this unknown type. \S \ref{polymorphism} covers our solution in depth.

    \item \emph{The type of messages must be tracked}

    The \picalc{} allows messages to contain both terms of a given base type, and channels of a given session type. Messages must track information about the type of their content. Moreover, this information must be kept at the type level, so that the typechecker is able to verify that processes make correct use of messages. Dependent types allow session types to be defined as an inductive type, and to then index the type of messages by the type of value they contain --- whether this is a session type or a base type. See \S \ref{messages} and \S \ref{processes} for more details.

    \item \emph{Channels can be used more than once, or not used at all}

    Our approach encodes session-typed channels as single-use channels that are created and destroyed with every action taken by a process. To invoke these actions, an appropriate session-typed channel has to provided. The action then use function abstraction to provide an environment in which a channel with the tail of the original session type is received as an argument. This channel passed as an argument must be used exactly once. Unfortunately, Coq has no support for linearity, and thus this property has to be checked ad-hoc. How to do this is covered in \S \ref{linearity}.

    \item \todo{introduce congruence and reduction}
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Encoding}\label{encoding}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Types}\label{types}

\coqi{../src/Types.v}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Polymorphism}\label{polymorphism}

\cite{Wadler1989}
\cite{Chlipala2008}
\todo{We use polymorphism to make channels opaque}
\todo{We do not do open processes}
\todo{We use polymorphism on messages to make processes traversable}

Polymorphism allows programs to depend on types. If those types are unconstrained --- if the universe of types is infinite --- then programs are unable pattern match on them (as they cannot possibly produce infinitely many cases) and unable to create terms inhabiting them. Such unconstrained polymorphic types are said to be \emph{opaque}. Programs depending on opaque types exhibit common general properties that are highlighted in \cite{Wadler1989}. This project makes use of polymorphism to prevent the creation and inspection of channels of a polymorphic type.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Messages}\label{messages}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Processes}\label{processes}

\cite{Vasconcelos2010}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Structural congruence}\label{structural-congruence}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Reduction}\label{reduction}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Linearity}\label{linearity}

One approach to simulating linearity is traversing processes \emph{a posteriori}, after they have been defined, to check that each channel is used exactly once. This can be done by making the type of channels parametric, and then instantiating it to $\mathbb{B}$ and \emph{marking} each channel for inspection. This allows both channel creation and message input to be modelled as function abstraction --- channels of a parametric type cannot be forged.  However, to be able to traverse processes where message passing is modelled as function abstraction, one has to be able to create all types of messages. To elude this problem, message types can be parametrised over a $\mathrm{Type} \rightarrow \mathrm{Type}$ function and then projected to the unit type.

\todo{mention the prize to pay}

\cite{Kobayashi1999}
\cite{Toninho2011}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Subject reduction}\label{subject-reduction}

\todo{Provide better example code, the things we do do not use the theorems}

Ensuring that linearity is preserved through reduction is therefore essential:
\begin{theorem}
    $lin(P) \Rightarrow P \rightarrow Q \Rightarrow lin(Q).$
\end{theorem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Examples}\label{examples}

\todo{Type inference}
\coqi{../src/Examples.v}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Results}\label{results}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Alternative approaches and related work}\label{related-work}


Unfortunately, the approach in point (i) makes it impossible for processes to use any logic that is external to the calculus and depends on the type of messages. An alternative approach for simulating linearity is by doing it \emph{a priori}, at construction time, by keeping track of the linearly available channels through a context by which processes are indexed.  This means that channel creation cannot be represented through function abstraction, that process composition needs to explicitly split the context, and that there must be a way of addressing a particular channel within a context --- strings with the Barendregt convention \cite{Barendregt1984}, De Bruijn indices \cite{deBruijn1972}, locally nameless De Bruijn indices, or a parametric HOAS \cite{Chlipala2008} --- since only channels need to be used linearly, message input can still be represented as function abstraction whenever the message does not contain a channel. On the bright side, this approach allows processes to use logic that external to the calculus and depends on the types of messages.

While the latter approach has more appealing properties, its mechanics negatively affect usability: can it be equipped with the usability of the former approach? I intend to create a Coq library that abstracts away the simulation of linearity.

\paragraph{Using de Bruijn indices}

\paragraph{Adding shared channels}
\todo{fixme}
Other efforts in formalising session types in Coq have created object languages and handled variable references, typing contexts, and typing judgments by hand \cite{Dilmore2019}.

Linearity is strongly connected to session types: a session type must transition through each of its stages \emph{exactly} once. Session types can be encoded into a \picalc{} with linear types, as shown by \cite{Kobayashi1996,Dardha2012,Dardha2016}. As shown in \cite{Voinea}, in systems where session types are shared, the tokens allowing access to the session-typed channels must still be linear.

The connection between session types and linearity can be drawn even further, at the logical level, where an isomorphism between linear logic and session types can be shown \cite{Caires2010} \cite{Wadler2014}. In \cite{Lindley2015} the operational semantics for a session-typed functional language that builds on Wadler's isomorphism are given. This work is continued in \cite{Lindley}, where the language is extended with polymorphism, row types, subkinding, and non-linear data types. \cite{Gay2010} uses a linear type-system to encode asynchronous session types with buffers --- and then verify properties of those buffers.

In type systems with no linear types the linearity of channels has to be simulated. In these type systems, modelling channels through a parametric higher order abstract syntax \cite{Chlipala2008} is not possible per se: the host language is unable to check whether the channels passed along as arguments are used linearly. This means that typing judgments must happen at the object language, through the use of a context that keeps track of linear resources.  This context is usually tracked at the type level, using inductive \emph{families} \cite{Dybjer1994} indexed by a context of linear resources \cite{Power2000} --- though there are approaches that keep track of context through type-classes and use monadic binding to embed a linear calculus within non-linear hosts \cite{Paykin2017}.

The \picalc{} has been an extensive subject of machine verification: \cite{Henry-Gerard1999} proofs subject reduction for it; \cite{Despeyroux2000} proofs subject reduction as well, but uses a higher order syntax; \cite{Affeldt2008} provides proofs of fairness and confluence; \cite{Honsell2001} formalises the bisimilarity proofs found in \cite{Walker1989}; \cite{Gay2001} provides a framework for formalisation on the \picalc{} with linear channels in Isabelle/HOL.

In \cite{Xi2016} session types are formalised in ATS, providing type preservation and global progress proofs. \cite{Bock2016} uses Celf to represent session types in intuitionistic linear logic.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}\label{conclusion}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{alpha}
\bibliography{mproj}
\end{document}
