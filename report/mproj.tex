\documentclass{mproj}
\usepackage{graphicx}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{fancyvrb}
\usepackage[final]{pdfpages}
\usepackage{times}
\usepackage{todonotes}
\usepackage{titlesec}
\usepackage{enumitem}
\setlist{nolistsep}
\usepackage{listings}
\input{lstcoq.sty}

% Inference rules
\usepackage{mathpartir}

% Links and their colors
\usepackage[
  colorlinks=true,
  linkcolor=darkgray,
  citecolor=darkgray,
  urlcolor=darkgray,
  ]{hyperref}

% Use a single line for chapter headers
% \titleformat{\chapter}[hang]{\normalfont\huge\bfseries}{\thechapter.}{1em}{} 
% Remove the space before chapter titles
% \titlespacing*{\chapter}{0pt}{0pt}{40pt}

% Appendices
\usepackage[header,title,titletoc]{appendix}
\renewcommand{\appendixname}{Appendix}

% License
\usepackage[
    type={CC},
    modifier={by-sa},
    version={3.0},
]{doclicense}

\usepackage[many]{tcolorbox}
\newtcolorbox{thesis-statement}[1]{%
    tikznode boxed title,
    enhanced,
    arc=0mm,
    interior style={white},
    attach boxed title to top center= {yshift=-\tcboxedtitleheight/2},
    fonttitle=\bfseries,
    colbacktitle=white,coltitle=black,
    boxed title style={size=normal,colframe=white,boxrule=0pt},
    title={#1}}

% Add bibliography to TOC
\usepackage[nottoc,numbib]{tocbibind}

\newtheorem{theorem}{Theorem}

% Commands for the pi-calculus
\newcommand{\PO}{\mathbf{0}}
\newcommand{\comp}[2]{#1 \mid #2}
\newcommand{\new}[2]{(\boldsymbol{\nu} #1 #2)}
\newcommand{\cout}[2]{\overline{#1}\langle#2\rangle.}
\newcommand{\cin}[2]{#1(#2).}
\newcommand{\select}[2]{#1\triangleleft#2.}
\newcommand{\branch}[2]{#1\triangleright#2}

\newcommand{\subst}[3]{#1[#2/#3]}

\newcommand{\picalc}{$\pi$-calculus}
\newcommand{\Picalc}{$\pi$-Calculus}

\newcommand{\type}{\texttt}
\newcommand{\End}{\type{End}}
\newcommand{\Send}[1]{!#1.}
\newcommand{\Recv}[1]{?#1.}
\newcommand{\Select}{\oplus}
\newcommand{\Branch}{\&}
\newcommand{\dual}{\overline}

\newcommand{\reduce}{\rightarrow}
\renewcommand{\emptyset}{\varnothing}
\newcommand{\types}{\vdash}
\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Type-checking\\ session-typed \picalc \\ with Coq}
\author{Uma Zalakain}
\date{2019-09-06}
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
    This project formalises the session-typed \picalc{} in Coq using a mix of continuation passing, parametric HOAS, dependent types and ad-hoc linearity checks. Each action a process takes requires a channel capable of that action. The head of that channel's type is then stripped off and its continuation is passed to the next action the process takes. Dependent types guarantee this continuation passing is correct by construction. The type of channels is parametrised over, so that users are unable to skip the proper mechanisms to create channels. The HOAS makes the syntax easy to use for both the end user and the designer: all variables are lifted to Coq, no typing contexts are required. The continuation passing always creates channels that must be used exactly once, but unfortunately Coq has no support for linearity, so this check needs to happen ad-hoc, by traversing processes. Ultimately, the claim is this: if the definition of a process typechecks in Coq, and the process uses channels linearly, then type safety and type preservation through reduction hold.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\educationalconsent
\vfill{}
\doclicenseThis
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgements}

Acknowledgements go here

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}\label{intro}

During the last decades, while the frequency at which processors run has peaked, the number of available processing units has kept growing. Computing has consequently shifted its focus into making processes safely communicate with one another --- no matter if they run concurrently on different CPU cores or on different hosts. The interest in the formalisation and verification of \emph{communicating concurrent} systems (where processes share no state and change as communication occurs) has grown as a result.

Communicating concurrent processes must satisfy some safety properties, such as following a pre-established communication protocol (where all messages sent by one process are expected by the other and vice versa) or communicating over private channels only known to the involved participants. To make properties like these easier to prove, formal models such as the \emph{\picalc{}} \cite{Walker1989,Milner1989,Milner1991,Sangiorgi2001} abstract real-world systems into suitable mathematical representations. \S \ref{pi-calculus} provides a brief overview of the \picalc.

The properties of a formal system can be verified either \emph{dynamically}, by monitoring processes at runtime, or \emph{statically}, by reasoning on the definition of the processes themselves.  Static guarantees --- while harder to define and sometimes more conservative than dynamic ones --- are \emph{total}, and thus satisfied regardless of the execution path. The basis of static verification is comprised of \emph{types} and \emph{type systems}, which are also the basis of programming languages and tools, making type-based verification techniques transferable to practical applications. An example of this are the plethora of types for communication and process calculi: from standard channel types, as you can find in e.g., Erlang or Go, to \emph{session types} \cite{Honda1993, Takeuchi1994, Honda1998}, a formalism used to specify and verify communication protocols (more in \S \ref{session-types}).

The mechanised formalisation and verification of programming languages and calculi is an ongoing community effort in securing existing work: humans are able to check proofs, but they are very likely to make mistakes; machines can verify proofs mechanically. A remarkable example of a community effort towards machine verification is RustBelt \cite{Dreyer2018}, a project that aims to formalise and machine-check the ownership system of the programming language Rust with the help of separation logic \cite{} and the proof assistant Coq. Not only does mechanisation increase confidence in what is mechanised, but also in all other derived work that is yet unverified: proving the correctness of Rust's type system immediately increases the confidence in all software written in it.

\todo{mention different methods to refer to variables}

\begin{thesis-statement}{THESIS STATEMENT}
    This project \emph{formalises the session-typed \picalc{}} using function abstraction to lift variable references to the host language. It then \emph{verifies subject reduction} for the resulting object language, which preserves \emph{communication privacy}, \emph{communication safety} and \emph{session fidelity} (refer to \S \ref{session-types-properties}).
\end{thesis-statement}

We choose Coq \cite{Coquand1989, CoqDeveloperCommunity} to machine-verify the session-typed \picalc{}, mainly due to its widespread use as a proof assistant (refer to \S \ref{coq} for an overview). A first challenge with Coq is that it offers \emph{no} support for \emph{linearity}, which is at the very heart of session types (as communication occurs, a session type must transition through each of its stages exactly once). As a result, extra work is required to simulate the linearity of the terms in the object language.

The present work simulates linearity by defining it as an inductive predicate on processes (\S \ref{linearity}). Once such a predicate establishes that a process uses channels linearly, the use of channels according to their specification is guaranteed by construction. As a consequence of this approach, \textbf{no typing contexts} are required in the host language and \textbf{variable references are lifted to Coq}, making the resulting syntax amicable to the user.

Other approaches to formalising process calculi are briefly exposed in \S \ref{related-work}. Closing, \S \ref{conclusion} suggests future work that might be of interest, and offers conclusions on what this project has achieved.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Background}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\picalc}\label{pi-calculus}

The \picalc{} \cite{Walker1989,Milner1989,Milner1991,Sangiorgi2001} is introduced as a way of modelling processes that change their structure by communicating with each other. The \picalc{} features \emph{channel mobility}, which allows communication channels to be sent over communication channels. In the \picalc{} any number of processes can communicate over a channel. While the \picalc{} can be typed, the type of a channel does \emph{not} evolve as communication occurs: it only specifies the type of data sent over it. An overview of the FAQs can be found in \cite{Wing2002}.

\subsection{Syntax}

\begin{align*}
P,Q ::= \; &\PO                                 & \text{inaction}             \\
           &\new{x}{y}P                         & \text{scope restriction}    \\
           &\cout{x}{u}P                        & \text{output}               \\
           &\cin{y}{u}P                         & \text{input}                \\
           &\select{x}{l_j}P                    & \text{selection}            \\
           &\branch{x}{\{l_i : P_i\}_{i \in I}} & \text{branching}            \\
           &\comp{P}{Q}                         & \text{parallel composition}
\end{align*}

The following example creates two linked channel endpoints $x$ and $y$ and composes two processes in parallel: one that uses $x$ to send integers $3$ and $4$, and then expect a response bound as $r$, do some $P$, then end; another that uses $y$ to receive $a$ and $b$, then send $a+b$, then end. Both processes communicate with one another when composed in parallel, changing their structure. Both channels $x$ and $y$ are of type \type{\#Int}).
\begin{align*}
\new{x}{y} (\comp{\cout{x}{3} \cout{x}{4} \cin{x}{r} P. \PO &}
                 {\cin{y}{a} \cin{y}{b} \cout{y}{a+b} \PO})
\reduce
\\
\new{x}{y} (\comp{\cout{x}{4} \cin{x}{r} P. \PO &}
                 {\cin{y}{b} \cout{y}{3+b} \PO})
\reduce
\\
\new{x}{y} (\comp{\cin{x}{r} P. \PO &}
                 {\cout{y}{3+4} \PO})
\reduce
\\
\new{x}{y} (\comp{\subst{P}{3+4}{r}. \PO &}
                 {\PO})
\equiv
\\
\subst{P}{3&+4}{r}
\end{align*}

\subsection{Structural congruence}

\begin{mathpar}
\inferrule
    { }
    {\comp{P}{Q} \equiv \comp{Q}{P}}
    \quad (\textsc{C-CompComm})

\inferrule
    { }
    {\new{x}{y} \new{z}{w} P \equiv \new{z}{w} \new{x}{y} P}
    \quad (\textsc{C-ScopeComm})

\inferrule
    { }
    {\comp{P}{\PO} \equiv P}
    \quad (\textsc{C-Comp0})

\inferrule
    { }
    {\comp {\comp{P}{Q}} {R} \equiv \comp {P} {\comp{Q}{R}}}
    \quad (\textsc{C-CompAssoc})

\inferrule
    { }
    {\new{x}{y} \PO \equiv \PO}
    \quad (\textsc{C-Scope0})

\inferrule
    {x,y \not\in fn(Q)}
    {\comp {(\new{x}{y}P)} {Q} \equiv \new{x}{y} \comp{P}{Q}}
    \quad (\textsc{C-ScopeExp})

\inferrule
    { }
    {\new{x}{y}P \equiv \new{y}{x}P}
    \quad (\textsc{C-ScopeSwap})
\end{mathpar}

\subsection{Reduction}

\begin{mathpar}
\inferrule 
    { }
    {\new{x}{y}(\comp {\cout{x}{a}P} {\cin{y}{b}Q}) \reduce
     \new{x}{y}(\comp {P}            {\subst{Q}{a}{b}})}
    \quad (\textsc{R-Comm})

\inferrule
    {j \in I}
    {\new{x}{y}(\comp {\select{x}{l_j}P} {\branch{y}{\{l_i : Q_i\}_{i \in I}}}) \reduce
     \new{x}{y}(\comp {P}                {Q_j})}
    \quad (\textsc{R-Case})

\inferrule
    {P \reduce Q}
    {\new{x}{y}P \reduce \new{x}{y}Q}
    \quad (\textsc{R-Res})

\inferrule
    {P \reduce Q}
    {\comp{P}{R} \reduce \comp{Q}{R}}
    \quad (\textsc{R-Par})

\inferrule
    {P \equiv P' \\ P' \reduce Q' \\ Q' \equiv Q}
    {P \reduce Q}
    \quad (\textsc{R-Struct})
\end{mathpar}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Session types}\label{session-types}

\todo{Can be binary (diadic) or multiparty}
\todo{Limit ourselves to channels with session types, no \#T}
\todo{Limit ourselves to linear types: $\circ$ is union of non intersecting sets}

Session types \cite{Honda1993, Takeuchi1994, Honda1998} are sequences of actions, each representing the type and the direction of the data exchanged.  Processes must use session-typed channels according to their specified protocol.  Instead of being shared and static, session types are linear, private to the communicating processes, and change as communication occurs. A comprehensive introduction to session types can be found in \cite{Vasconcelos2009}, while answers to FAQs are compiled in \cite{Dezani-ciancaglini2010}. The process above introduced as an example of the \picalc{} would have the session-types of its channels evolve through communication as follows (\type{!} denotes sending, \type{?} receiving):
\begin{align*}
x : \type{\Send{Int}\Send{Int}\Recv{Int}\End} &,\;
y : \type{\Recv{Int}\Recv{Int}\Send{Int}\End}
\reduce
\\
x : \type{\Send{Int}\Recv{Int}\End} &,\;
y : \type{\Recv{Int}\Send{Int}\End}
\reduce
\\
x : \type{\Recv{Int}\End} &,\;
y : \type{\Send{Int}\End}
\reduce
\\
x : \type{\End} &,\;
y : \type{\End}
\end{align*}

\subsection{Typing rules}

Session-typed channels restrict the syntax of the \picalc{}:

\begin{mathpar}
\inferrule
    {\Gamma \types x : \End}
    {\Gamma \types \PO}
    \quad (\textsc{T-Inact})

\inferrule
    {\Gamma_1 \types P \\
     \Gamma_2 \types Q}
    {\Gamma_1 \circ \Gamma_2 \types \comp{P}{Q}}
    \quad (\textsc{T-Par})

\inferrule
    {\Gamma,x:T,y:\dual{T} \types P}
    {\Gamma \types \new{x}{y}P}
    \quad (\textsc{T-Res})

\inferrule
    {\Gamma_1 \types x:\Recv{T}S \\
     \Gamma_2,x:S,y:T \types P}
    {\Gamma_1 \circ \Gamma_2 \types \cin{x}{y}P}
    \quad (\textsc{T-In})

\inferrule
    {\Gamma_1 \types x:\Send{T}S \\
     \Gamma_2 \types v:T \\
     \Gamma_3,x:S \types P}
    {\Gamma_1 \circ \Gamma_2 \circ \Gamma_3 \types \cout{x}{v}P}
    \quad (\textsc{T-Out})

\inferrule
    {\Gamma_1 \types x:\Branch{\{l_i : S_i\}_{i \in I}} \\
     \Gamma_2,x:S_i \types P_i \\
     \forall i \in I}
    {\Gamma_1 \circ \Gamma_2 \types x \branch{\{l_i : P_i\}_{i \in I}}}
    \quad (\textsc{T-Branch})

\inferrule
    {\Gamma_1 \types x:\Select{\{l_i : S_i\}_{i \in I}} \\
     \Gamma_2,x:S_i \types P_i \\
     \exists j \in I}
    {\Gamma_1 \circ \Gamma_2 \types x \select{l_j}P}
    \quad (\textsc{T-Select})
\end{mathpar}

\subsection{Duality}

It is worth noting that in the introduced example the session types of $x$ and $y$ must be \emph{dual}: when one channel sends a type \type{T}, the other must receive \type{T}, and then both must continue dually. Duality and linearity (a session type must transition through each of its stages exactly once) are the basis for the properties that session types guarantee.

\begin{mathpar}
\inferrule{}{\dual{\Send{T}S} = \Recv{T}\dual{S}}

\inferrule{}{\dual{\Recv{T}S} = \Send{T}\dual{S}}

\inferrule{}{
    \dual{\Branch \{l_i : S_i\}_{i \in I}} =
    \Select \{l_i : \dual{S_i}\}_{i \in I}}

\inferrule{}{
    \dual{\Select\{l_i : S_i\}_{i \in I}} =
    \Branch \{l_i : \dual{S_i}\}_{i \in I}}

\inferrule{}{\dual{\End} = \End}
\end{mathpar}

\subsection{Properties}\label{session-types-properties}

Session types guarantee:

\begin{description}
    \item [communication privacy] at any given moment exactly two processes communicate over a channel;
        
    \item [session fidelity] processes follow session types sequentially; and 
        
    \item [communication safety] processes only send what their counterpart is expecting to receive.
\end{description}
        

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Coq proof assistant}\label{coq}

Coq \cite{CoqDeveloperCommunity} is a popular proof assistant and dependently typed functional language based on the calculus of inductive constructions \cite{Coquand1989} (which adds inductive data types to the calculus of constructions \cite{Coquand1985}), a type theory isomorphic to intuitionistic predicate calculus --- a constructive logic with quantified statements.

Since types may contain arbitrary definitions, definitions in Coq must exhibit termination --- recursion must occur on structurally smaller terms. Coq supports inductive and coinductive data types, and features proof irrelevance for proofs (in \type{Prop}) and a cumulative set of universes (in \type{Type}).

Coq allows users to build proofs using \emph{tactics}: programs written in $L_{tac}$ that manipulate hypotheses and transform goals. While these programs might be incorrect, or not terminate, their outcome is ultimately checked by \emph{Gallina}, the specification language of Coq.

In Coq, simultaneously pattern matching on multiple indexed data types can be rather clunky and arduous. The \emph{Equations} package eases this inconvenience by adding equational definitions, pattern matching on the left, and \texttt{with} constructs (\cite{McBride2004}), making Coq as convenient for dependent pattern matching as Agda.

\todo{Example proofs}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Polymorphism}\label{polymorphism}

\cite{Wadler1989}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Dependent types}\label{dependent-types}

Types that depend on programs
\todo{Indexed datatypes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Design}\label{design}

This chapter covers the high-level design of the encoding of the session-typed \picalc{} into Coq. \todo{The main goal is using function abstraction}

Other efforts in formalising session types in Coq have created object languages and handled variable references, typing contexts, and typing judgments by hand \cite{Dilmore2019}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview}\label{overview}



Central to computing session-typed \picalc is the need to handle the state transitions of session types. One approach is \emph{continuation passing}, introduced in \S \ref{continuation-passing}, which destroys channels and creates new ones as part of every action of a process \cite{Dardha2016}. While there exist other approaches \todo{citation needed}, they all require for every state a session type is in to be used exactly once, i.e. linearity, discussed in \S \ref{linearity}.

\todo{mention the prize to pay}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Continuation passing}\label{continuation-passing}

\cite{Vasconcelos2010}
\todo{We merge pi calculus and session types into one}


Assuming linearity, \textbf{processes are correct by construction}: the processes that can be constructed depend on the session types of the channels in the environment of the host language; an action strips off the outer layer of a channel's session type -- modelling \textbf{continuation passing}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Linearity}\label{linearity}

\cite{Kobayashi1999}
\cite{Toninho2011}

One approach to simulating linearity is traversing processes \emph{a posteriori}, after they have been defined, to check that each channel is used exactly once. This can be done by making the type of channels parametric, and then instantiating it to $\mathbb{B}$ and \emph{marking} each channel for inspection. This allows both channel creation and message input to be modelled as function abstraction --- channels of a parametric type cannot be forged.  However, to be able to traverse processes where message passing is modelled as function abstraction, one has to be able to create all types of messages. To elude this problem, message types can be parametrised over a $\mathrm{Type} \rightarrow \mathrm{Type}$ function and then projected to the unit type.
    
Unfortunately, the approach in point (i) makes it impossible for processes to use any logic that is external to the calculus and depends on the type of messages. An alternative approach for simulating linearity is by doing it \emph{a priori}, at construction time, by keeping track of the linearly available channels through a context by which processes are indexed.  This means that channel creation cannot be represented through function abstraction, that process composition needs to explicitly split the context, and that there must be a way of addressing a particular channel within a context --- strings with the Barendregt convention \cite{Barendregt1984}, De Bruijn indices \cite{deBruijn1972}, locally nameless De Bruijn indices, or a parametric HOAS \cite{Chlipala2008} --- since only channels need to be used linearly, message input can still be represented as function abstraction whenever the message does not contain a channel. On the bright side, this approach allows processes to use logic that external to the calculus and depends on the types of messages.

While the latter approach has more appealing properties, its mechanics negatively affect usability: can it be equipped with the usability of the former approach? I intend to create a Coq library that abstracts away the simulation of linearity.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Parametric HOAS}\label{phoas}

\cite{Wadler1989}
\cite{Chlipala2008}
\todo{We use polymorphism to make channels opaque}
\todo{We do not do open processes}
\todo{We use polymorphism on messages to make processes traversable}

The introduction of both channels and received messages is modelled as function abstraction in Coq, therefore \textbf{variables are handled transparently} -- no substitution related lemmas are required. Channel types are parametrised to make them opaque -- they cannot be illicitly created or inspected by the user.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Subject reduction}\label{subject-reduction}

Ensuring that linearity is preserved through reduction is therefore essential:
\begin{theorem}
    $lin(P) \Rightarrow P \rightarrow Q \Rightarrow lin(Q).$
\end{theorem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation}\label{implementation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Session types}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Messages and processes}\label{processes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Linearity check}\label{linearity-check}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Linearity preservation}\label{linearity-preservation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Examples}\label{examples}

\todo{Type inference}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Related work}\label{related-work}

Linearity is strongly connected to session types: a session type must transition through each of its stages \emph{exactly} once. Session types can be encoded into a \picalc{} with linear types, as shown by \cite{Kobayashi1996,Dardha2012,Dardha2016}. As shown in \cite{Voinea}, in systems where session types are shared, the tokens allowing access to the session-typed channels must still be linear.

The connection between session types and linearity can be drawn even further, at the logical level, where an isomorphism between linear logic and session types can be shown \cite{Caires2010} \cite{Wadler2014}. In \cite{Lindley2015} the operational semantics for a session-typed functional language that builds on Wadler's isomorphism are given. This work is continued in \cite{Lindley}, where the language is extended with polymorphism, row types, subkinding, and non-linear data types. \cite{Gay2010} uses a linear type-system to encode asynchronous session types with buffers --- and then verify properties of those buffers.

In type systems with no linear types the linearity of channels has to be simulated. In these type systems, modelling channels through a parametric higher order abstract syntax \cite{Chlipala2008} is not possible per se: the host language is unable to check whether the channels passed along as arguments are used linearly. This means that typing judgments must happen at the object language, through the use of a context that keeps track of linear resources.  This context is usually tracked at the type level, using inductive \emph{families} \cite{Dybjer1994} indexed by a context of linear resources \cite{Power2000} --- though there are approaches that keep track of context through type-classes and use monadic binding to embed a linear calculus within non-linear hosts \cite{Paykin2017}.

The \picalc{} has been an extensive subject of machine verification: \cite{Henry-Gerard1999} proofs subject reduction for it; \cite{Despeyroux2000} proofs subject reduction as well, but uses a higher order syntax; \cite{Affeldt2008} provides proofs of fairness and confluence; \cite{Honsell2001} formalises the bisimilarity proofs found in \cite{Walker1989}; \cite{Gay2001} provides a framework for formalisation on the \picalc{} with linear channels in Isabelle/HOL.

In \cite{Xi2016} session types are formalised in ATS, providing type preservation and global progress proofs. \cite{Bock2016} uses Celf to represent session types in intuitionistic linear logic.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}\label{conclusion}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{alpha}
\bibliography{mproj}
\end{document}
