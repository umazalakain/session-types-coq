\documentclass{mproj}
\usepackage{graphicx}

\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{fancyvrb}
\usepackage[final]{pdfpages}
\usepackage{times}
\usepackage{todonotes}
\usepackage{titlesec}
\usepackage{enumitem}
\setlist{nolistsep}

% Links and their colors
\usepackage[
  colorlinks=true,
  linkcolor=darkgray,
  citecolor=darkgray,
  urlcolor=darkgray,
  ]{hyperref}

% Use a single line for chapter headers
\titleformat{\chapter}[hang]{\normalfont\huge\bfseries}{\thechapter.}{1em}{} 
% Remove the space before chapter titles
\titlespacing*{\chapter}{0pt}{0pt}{40pt}

% Appendices
\usepackage[header,title,titletoc]{appendix}
\renewcommand{\appendixname}{Appendix}

% License
\usepackage[
    type={CC},
    modifier={by-sa},
    version={3.0},
]{doclicense}

% Add bibliography to TOC
\usepackage[nottoc,numbib]{tocbibind}

\newtheorem{theorem}{Theorem}

% for alternative page numbering use the following package
% and see documentation for commands
%\usepackage{fancyheadings}


% other potentially useful packages
%\uspackage{amssymb,amsmath}
%\usepackage{url}
%\usepackage{fancyvrb}
%\usepackage[final]{pdfpages}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{$\pi$-calculus session types in Coq \\
\large Using a parametric higher order abstract syntax with dependent types}
\author{Uma Zalakain}
\date{2019-09-06}
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
abstract goes here
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\educationalconsent
\vfill{}
\doclicenseThis
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgements}

acknowledgements go here

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}\label{intro}

The pi calculus models the exchange of messages between processes over
two-endpoint communication channels. When two processes exchange a message
through a channel computation advances: the receiving process gets reduced
through substitution. Channels themselves can also be sent as messages, and then
be used for further communication.

It is often desirable to restrict the processes that are expressible to those
that are deemed meaningful, leaving out the ones with undesirable features. This
is usually accomplished by adding a type system to the calculus. In the pi
calculus, session types can be used to impose types onto channel endpoints --
the session type of a channel endpoint is a finite sequence of types, each with
an associated direction.

The two endpoints of a channel must have dual session types: if one end is
sending data of type \texttt{T}, the other must be receiving data of type
\texttt{T} -- ensuring \textit{communication safety}. Channel endpoints can be
passed along as messages, but can never be duplicated: communication must only
ever occur between two processes -- ensuring \textit{privacy}.  Processes must
follow the session types of channel endpoints: channels must be used as per
their specification -- ensuring \textit{session fidelity}. As communication
occurs and messages are exchanged, the session types of channels advance.
Ensuring that this reduction process respects session types involves proving
both \textit{subject reduction} and \textit{type soundness}. \cite{Dardha2016m}

Using a proof assistant to prove these theorems provides a strong guarantee of
the correctness. Moreover, it means that any process described in these terms
will have these theorems automatically derived. From the numerous proof
assistants available, this project uses Coq to formalise the pi calculus with
session types. Amongst its features, Coq includes a powerful tactic engine and a
dependent type system, both key for the development of this project.

Past efforts in formalising session types in Coq have created an object language
and handled variable references, typing contexts, and typing judgments manually
\cite{Dilmore2019}. The present work lifts those responsibilities to the
metalanguage by using a parametric higher order abstract syntax to model
processes. This results in the following key features:

\begin{description}
    \item [Variable references]
        The introduction of both channels and received messages is modelled as
        function abstraction in Coq and therefore handled transparently -- no
        substitution related lemmas are required. Channel types are parametrised
        to make them opaque -- no cheating is allowed.

    \item [Congruence and reduction]
        Congruence and reduction are inductively defined on processes --
        reduction by message passing requires pattern matching on function
        definitions. Tactics are used to find congruent processes that reduce.

    \item [Type preservation]
        Assuming linearity, processes are \textbf{correct by construction}:
        the processes that can be constructed depend on the session types in the
        environment; an action strips off the outer layer of a channel's session
        type -- modelling \textbf{continuation passing}.

        Ensuring that linearity is preserved through reduction is therefore
        essential:
        \begin{theorem}
        If $P$ is linear and $P$ reduces to $Q$, then $Q$ is linear.
        \end{theorem}
\end{description}

\todo{mention we only do closed processes}
\todo{mention we keep nothing in context}
\todo{mention parametric HOAS and dependent types somewhere}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% it is fine to change the bibliography style if you want
\bibliographystyle{plain}
\bibliography{mproj}
\end{document}
