\documentclass{mproj}

\usepackage[utf8]{inputenc}

% Coq code
\usepackage[dvipsnames]{xcolor}
\usepackage{listingsutf8}
\input{lstcoq.sty}

% Multiple colunms
\usepackage{multicol}
\setlength{\columnseprule}{1pt}

% Math
\usepackage{amsmath}
\usepackage{amssymb}

% Use times font
\usepackage{times}

% They are all over the place
\usepackage{todonotes}

% Allows to place figures HERE!
\usepackage{float}

% Enums
\usepackage[inline]{enumitem}
\setlist{nolistsep}

% Inference rules
\usepackage{mathpartir}

% Links and their colors
\usepackage{url}
\usepackage[
  colorlinks=true,
  linkcolor=darkgray,
  citecolor=darkgray,
  urlcolor=darkgray,
  ]{hyperref}

\usepackage{titlesec}
% Use a single line for chapter headers
\titleformat{\chapter}[hang]{\normalfont\huge\bfseries}{\thechapter.}{1em}{} 
% Remove the space before chapter titles
\titlespacing*{\chapter}{0pt}{0pt}{40pt}

% Appendices
\usepackage[header,title,titletoc]{appendix}
\renewcommand{\appendixname}{Appendix}

% License
\usepackage[
    type={CC},
    modifier={by-sa},
    version={3.0},
]{doclicense}

% Add bibliography to TOC
\usepackage[nottoc,numbib]{tocbibind}

% Switch off page numbering for noe
\pagenumbering{gobble}


\newtheorem{theorem}{Theorem}

% Commands for the pi-calculus
\newcommand{\PO}{\mathbf{0}}
\newcommand{\comp}[2]{#1 \mid #2}
\newcommand{\new}[2]{(\boldsymbol{\nu} #1 #2) \;}
\newcommand{\cout}[2]{\overline{#1}\langle#2\rangle.}
\newcommand{\cin}[2]{#1(#2).}
\newcommand{\select}[2]{#1\triangleleft#2.}
\newcommand{\branch}[2]{#1\triangleright#2}
\newcommand{\subst}[3]{#1[#2/#3]}
\newcommand{\picalc}{$\pi$-calculus}
\newcommand{\Picalc}{$\pi$-Calculus}
\newcommand{\type}{\texttt}
\newcommand{\End}{\type{End}}
\newcommand{\Send}[1]{!#1.}
\newcommand{\Recv}[1]{?#1.}
\newcommand{\Select}{\oplus}
\newcommand{\Branch}{\&}
\newcommand{\dual}{\overline}
\newcommand{\reduce}{\rightarrow}
\renewcommand{\emptyset}{\varnothing}
\newcommand{\types}{\vdash}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Type-checking\\ session-typed \picalc \\ with Coq}
\author{Uma Zalakain}
\date{2019-09-06}
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
\todo{go over this again}
    This project formalises the session-typed \picalc{} in Coq using a mix of continuation passing, parametric HOAS, dependent types and ad-hoc linearity checks. Each action a process takes requires a channel capable of that action. The head of that channel's type is then stripped off and its continuation is passed to the next action the process takes. Dependent types guarantee this continuation passing is correct by construction. The type of channels is parametrised over, so that users are unable to skip the proper mechanisms to create channels. The HOAS makes the syntax easy to use for both the end user and the designer: all variables are lifted to Coq, no typing contexts are required. The continuation passing always creates channels that must be used exactly once, but unfortunately Coq has no support for linearity, so this check needs to happen ad-hoc, by traversing processes. Ultimately, the claim is this: if the definition of a process typechecks in Coq, and the process uses channels linearly, then type safety and type preservation through reduction hold.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\educationalconsent
\vfill{}
\doclicenseThis
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgements}

This thesis has been nearly four months in the making. Particularly during the early days, but all the way throughout, the guidance and care offered by my supervisor Ornela Dardha has played a crucial role in the steering of this project. Everything I learned about the \picalc{} and session types I learned through her.

Although limited, my ability to do dependent typed programming  and think of propositions as types and of proofs as programs is entirely due to Conor McBride and the people at Strathclyde (especially Fredrik Nordvall and Bob Atkey). Others have inspired me as well, notably Wen Kokke and James Wood.

The nice people on the \#coq, \#agda and \#dependent channels on Freenode are to thank for answering many of my (often silly) questions. Special thanks to Paolo Giarrusso. I also want to thank the developers of the Equations package for Coq: it has avoided me many dependently typed headaches.

Lastly, and perhaps most importantly, I want to thank the people close to me: my girlfriends Mia and Tilde, my friends, and my family. They are the ones that have provided the care and affection that has kept me afloat.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}\label{intro}
% Start page numbering here
\pagenumbering{arabic}

During the last decades, while the frequency at which processors run has peaked, the number of available processing units has kept growing. Computing has consequently shifted its focus into making processes safely communicate with one another --- no matter if they run concurrently on different CPU cores or on different hosts. The interest in the formalisation and verification of \emph{communicating concurrent} systems (where processes share no state and change as communication occurs) has grown as a result.

Communicating concurrent processes must satisfy some safety properties, such as following a pre-established communication protocol (where all messages sent by one process are expected by the other and vice versa) or communicating over private channels only known to the involved participants. To make properties like these easier to prove, formal models such as the \emph{\picalc{}} \cite{Walker1989,Milner1989,Milner1991,Sangiorgi2001} abstract real-world systems into suitable mathematical representations. \S \ref{pi-calculus} provides a brief overview of the \picalc.

The properties of a formal system can be verified either \emph{dynamically}, by monitoring processes at runtime, or \emph{statically}, by reasoning on the definition of the processes themselves.  Static guarantees --- while harder to define and sometimes more conservative than dynamic ones --- are \emph{total}, and thus satisfied regardless of the execution path. The basis of static verification is comprised of \emph{types} and \emph{type systems}, which are also the basis of programming languages and tools, making type-based verification techniques transferable to practical applications. An example of this are the plethora of types for communication and process calculi: from standard channel types, as found in e.g., Erlang or Go, to \emph{session types} \cite{Honda1993, Takeuchi1994, Honda1998}, a formalism used to specify and verify communication protocols (more in \S \ref{session-types}).

The mechanised formalisation and verification of programming languages and calculi is an ongoing community effort in securing existing work: humans are able to check proofs, but they are very likely to make mistakes; machines can verify proofs mechanically. A remarkable example of a community effort towards machine verification is RustBelt \cite{Dreyer2018}, a project that aims to formalise and machine-check the ownership system of the programming language Rust with the help of separation logic \cite{} and the proof assistant Coq. Not only does mechanisation increase confidence in what is mechanised, but also in all other derived work that is yet unverified: proving the correctness of Rust's type system immediately increases the confidence in all software written in it.

\begin{center}
    \emph{This project formalises and verifies a subset of the session-typed \picalc{}.}
\end{center}

We choose Coq \cite{Coquand1989, CoqDeveloperCommunity} to machine-verify the session-typed \picalc{}, mainly due to its widespread use as a proof assistant (refer to \S \ref{coq} for an overview). A first challenge with Coq is that it offers \emph{no} support for \emph{linearity}, which is at the very heart of session types (as communication occurs, a session type must transition through each of its stages exactly once). As a result, extra work is required to simulate the linearity of the terms in the object language.

We use a higher order abstract syntax \cite{Chlipala2008} to lift bindings (of both channels and messages) in the object language into bindings in Coq. As a result, the object language requires \emph{no typing contexts} and \emph{no substitution lemmas}. Linearity is simulated through an inductive predicate on processes (\S \ref{linearity}). Dependent types ensure that processes are correct by construction up to linearity: processes satisfying the linearity predicate are guaranteed to use session-typed channels according to their specification.

We provide basic background on the \picalc{}, session types and Coq in \S \ref{background}. We then introduce our design in \S \ref{design} and comment on the results in \S \ref{results}. Alternative approaches are introduced in \S \ref{related-work}. Closing, \S \ref{conclusion} suggests future work of interest, and offers conclusions on what this project has achieved.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Background}\label{background}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\picalc}\label{pi-calculus}

\paragraph{Scope} This section provides an overview of the \picalc{} as introduced in \cite{Sangiorgi2001}. However, it deliberately ignores replication and indeterministic choice, part of the \picalc{} but not covered by this project. Additionally, and as preliminary preparation for the introduction of session types, this section presents channel restriction by introducing two channel \emph{endpoints}, instead of the usual single variable used for channels.

The \picalc{} \cite{Walker1989,Milner1989,Milner1991,Sangiorgi2001} models processes that progress and change their structure by using \emph{channels} to communicate with one another. The \picalc{} features \emph{channel mobility}, which allows channels to be sent over channels themselves. In the \picalc{} any number of processes can communicate over a channel. While the \picalc{} can be typed, the type of a channel does \emph{not} evolve as communication occurs: it only specifies the type of data sent over it. An overview of the FAQs can be found in \cite{Wing2002}.

The syntax of the \picalc{} is given by the grammar in Figure \ref{picalc-syntax}. Inaction denotes the end of a process, and has therefore no continuation. Scope restriction creates a new communication channel between endpoints $x$ and $y$, which are bound in $P$. Output sends $u$ over the channel endpoint $x$, and then continues as $P$. Input waits to receive $u$ on the endpoint $y$; upon reception $u$ is bound in $P$. Selection sends the choice of process $l_j$ over $x$, and then continues as $P$. Branching offers choices over $I$, where the choice $l_i$ selects the continuation process $P_i$. Parallel composition runs processes $P$ and $Q$ in parallel, allowing these processes to communicate over shared channels.

\begin{figure}[H]
    \begin{align*}
    P,Q ::= \; &\PO                      & \text{inaction}             \\
               &\new{x}{y}P              & \text{scope restriction}    \\
               &\cout{x}{u}P             & \text{output}               \\
               &\cin{y}{u}P              & \text{input}                \\
               &\branch{x}
               {\{l_i : P_i\}_{i \in I}} & \text{branching}            \\
               &\select{x}{l_j}P         & \text{selection}            \\
               &\comp{P}{Q}              & \text{parallel composition}
    \end{align*}
    \caption{Grammar describing the syntax of the \picalc{}}
    \label{picalc-syntax}
\end{figure}

The syntax of the \picalc{} captures undesired syntactical properties of processes (e.g. associativity should not matter when three processes are composed in parallel). Structural congruence is introduced as a way to abstract over these unintended differences in syntax. It is defined by the smallest congruent equivalence relation that satisfies the inference rules in Figure \ref{picalc-congruence} -- a congruent equivalence relation in itself is the smallest relation that is reflexive, symmetric, transitive and congruent. Worth noting is the structural congruence rule for scope expansion: the scope of bound variables can include or exclude a process at will, as long as the bound variables do not appear free in that process. The congruence rule states that if two processes considered equal are placed within a common context, then the resulting contexts are equal as well (a context is a process where some occurrence of $\PO$ is substituted by a \emph{hole} that can then be filled in with a process). Said otherwise, structural congruence \emph{goes under} the syntactic constructs of the \picalc{}.

\begin{figure}[H]
    \begin{mathpar}
    \inferrule
        { }
        {\comp{P}{Q} \equiv \comp{Q}{P}}
        \quad (\textsc{C-CompComm})

    \inferrule
        { }
        {\new{x}{y} \new{z}{w} P \equiv \new{z}{w} \new{x}{y} P}
        \quad (\textsc{C-ScopeComm})

    \inferrule
        { }
        {\comp{P}{\PO} \equiv P}
        \quad (\textsc{C-Comp0})

    \inferrule
        { }
        {\comp {(\comp{P}{Q})} {R} \equiv \comp {P} {(\comp{Q}{R})}}
        \quad (\textsc{C-CompAssoc})

    \inferrule
        { }
        {\new{x}{y} \PO \equiv \PO}
        \quad (\textsc{C-Scope0})

    \inferrule
        { }
        {\new{x}{y}P \equiv \new{y}{x}P}
        \quad (\textsc{C-ScopeSwap})

    \inferrule
        {x,y \not\in fn(Q)}
        {\comp {(\new{x}{y}P)} {Q} \equiv \new{x}{y} \comp{P}{Q}}
        \quad (\textsc{C-ScopeExp})

    \end{mathpar}
    \caption{Structural congruence rules for the \picalc{}}
    \label{picalc-congruence}
\end{figure}

The operational semantics of the \picalc{} is specified by reduction rules, defined in Figure \ref{picalc-reduction}. Two parallel processes communicating over the same channel (by using opposite endpoints to send and receive a message) get reduced to the parallel composition of their continuations, with the continuation of the receiving process having all the references to the message substituted by the message term itself (\textsc{R-Comm}). Similarly, a process that makes a choice put in parallel with a process that offers a choice gets reduced to the continuation of the choosing process and the chosen continuation of the process offering the choice -- so long as the choice itself is valid (\textsc{R-Case}). Reduction goes under both restriction (\textsc{R-Res}) and parallel composition (\textsc{R-Par}), but not under output, input, selection or branching -- constructs that impose order in the communication. Finally, reduction is defined up to structural congruence: any amount of syntax rewriting can be performed before and after reduction  (\textsc{R-Struct}).

\begin{figure}[H]
    \begin{mathpar}
    \inferrule 
        { }
        {\new{x}{y}(\comp {\cout{x}{a}P} {\cin{y}{b}Q}) \reduce
         \new{x}{y}(\comp {P}            {\subst{Q}{a}{b}})}
        \quad (\textsc{R-Comm})

    \inferrule
        {j \in I}
        {\new{x}{y}(\comp {\select{x}{l_j}P} {\branch{y}{\{l_i : Q_i\}_{i \in I}}}) \reduce
         \new{x}{y}(\comp {P} {Q_j})}
        \quad (\textsc{R-Case})

    \inferrule
        {P \reduce Q}
        {\new{x}{y}P \reduce \new{x}{y}Q}
        \quad (\textsc{R-Res})

    \inferrule
        {P \reduce Q}
        {\comp{P}{R} \reduce \comp{Q}{R}}
        \quad (\textsc{R-Par})

    \inferrule
        {P \equiv P' \\ P' \reduce Q' \\ Q' \equiv Q}
        {P \reduce Q}
        \quad (\textsc{R-Struct})
    \end{mathpar}
    \caption{Reduction rules for the \picalc{}}
    \label{picalc-reduction}
\end{figure}

As an example, Figure \ref{picalc-example} creates two linked channel endpoints $x$ and $y$ and then composes two processes in parallel: one that uses $x$ to send integers $3$ and $4$, and then expect a response bound as $r$, do some $P$, then end; another that uses $y$ to receive $a$ and $b$, then send $a+b$, then end. Both processes communicate with one another when composed in parallel, changing their structure.

\begin{figure}[H]
    \begin{align*}
    \new{x}{y} (\comp{\cout{x}{3} \cout{x}{4} \cin{x}{r} P. \PO &}
                     {\cin{y}{a} \cin{y}{b} \cout{y}{a+b} \PO})
    \reduce
    \\
    \new{x}{y} (\comp{\cout{x}{4} \cin{x}{r} P. \PO &}
                     {\cin{y}{b} \cout{y}{3+b} \PO})
    \reduce
    \\
    \new{x}{y} (\comp{\cin{x}{r} P. \PO &}
                     {\cout{y}{3+4} \PO})
    \reduce
    \\
    \new{x}{y} (\comp{\subst{P}{3+4}{r}. \PO &}
                     {\PO})
    \equiv
    \\
    \subst{P}{3&+4}{r}
    \end{align*}
    \caption{Example process in the \picalc{}}
    \label{picalc-example}
\end{figure}

The grammar for the \picalc{} allows well-formed processes with no semantic meaning (e.g. $\new{x}{y} \comp {\cout{x}{true}\PO} {\cin{y}{u}(u+3).\PO}$). The syntax rules for the construction of \picalc{} terms can be refined to discard some of these constructs. One such refinement are shared types (Figure \ref{picalc-shared-types}), which ensure that the types of channels and messages match -- in the example in Figure \ref{picalc-example}, channel endpoints $x$ and $y$ would need to be of the shared base type \type{Int} for the processes to be well-typed. The formation of \picalc{} terms can be further restricted with \emph{session types}: types that serve to specify communication protocols.

\begin{figure}[H]
    \begin{align*}
    T ::= \; &\type{Chan}[T] & \text{channel type} \\
             &\ldots         & \text{base type}
    \end{align*}
    \caption{Shared types for the \picalc{}}
    \label{picalc-shared-types}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Session types}\label{session-types}

\paragraph{Scope} This section covers a subset of session types: the diadic (shared by two processes), finite (no replication or recursion), deterministic (no indeterministic choice), and synchronous session types.

Session types \cite{Honda1993, Takeuchi1994, Honda1998} encode sequences of actions, each action containing the type and the direction of the data exchanged.  Processes must use session-typed channels according to their specified protocol.  Instead of being shared and static, session types are linear, private to the communicating processes, and changing as communication occurs. A comprehensive introduction to session types can be found in \cite{Vasconcelos2009}, while answers to FAQs are compiled in \cite{Dezani-ciancaglini2010}.

The grammar of session types is listed in the Figure \ref{session-types-grammar}. Channel termination admits no continuation. For sending and receiving, the type of the transmitted data and the session type of the continuation are required. The types transmitted can either be base types or session types. Branching and selection both expect a set of session types which contains the continuation that will be chosen. In the example process introduced in Figure \ref{picalc-example}, the session type of $x$ is $\type{\Send{Int}\Send{Int}\Recv{Int}\End}$, while the one of $y$ is $\type{\Recv{Int}\Recv{Int}\Send{Int}\End}$

\begin{figure}[H]
    \begin{align*}
        M ::= \; &S      & \text{session type}\\
                 &\ldots & \text{base type}
                 \\
        S ::= \; &\type{End}                      & \text{termination} \\
                 &\Send{M}S                       & \text{send} \\
                 &\Recv{M}S                       & \text{receive} \\
                 &\Branch \{l_i : S_i\}_{i \in I} & \text{branch} \\
                 &\Select \{l_i : S_i\}_{i \in I} & \text{select} \\
    \end{align*}
    \caption{Grammar for session types}
    \label{session-types-grammar}
\end{figure}

Note that the session types of $x$ and $y$ must be \emph{dual}: when one channel sends a type \type{T}, the other must receive \type{T}, and then both must continue dually. The precise definition of duality is given in Figure \ref{session-types-duality}. Duality is one of the core principles of session types, as it guarantees \emph{communication safety}.

\begin{figure}[H]
    \begin{mathpar}
    \inferrule{}{\dual{\Send{T}S} = \Recv{T}\dual{S}}

    \inferrule{}{\dual{\Recv{T}S} = \Send{T}\dual{S}}

    \inferrule{}{
        \dual{\Branch \{l_i : S_i\}_{i \in I}} =
        \Select \{l_i : \dual{S_i}\}_{i \in I}}

    \inferrule{}{
        \dual{\Select\{l_i : S_i\}_{i \in I}} =
        \Branch \{l_i : \dual{S_i}\}_{i \in I}}

    \inferrule{}{\dual{\End} = \End}
    \end{mathpar}
    \caption{Duality on session types}
    \label{session-types-duality}
\end{figure}

Session-typed channels impose typing rules on the syntactical constructs of the \picalc{}: a process can perform an action on a channel only if that channel is capable of the action. The typing rules for processes using session typed channels are shown in Figure \ref{session-types-typing-rules}. The judgment $\Gamma \types P$ signifies that $P$ is well typed under the context $\Gamma$. Contexts are linear: their elements cannot be duplicated nor discarded. The disjoint union operator $\circ$ represents context split: every element in the context $\Gamma_1 \circ \Gamma_2$ must appear exactly once in one of $\Gamma_1$ or $\Gamma_2$, but not in both.

A process can be terminated if the only channel in context is a channel that is expecting to be terminated --- thus premature termination is avoided. Restriction creates two linked channel endpoints, where these endpoints are dual. Parallel composition splits the linear context in two. Input requires a channel capable of receiving and a continuation process typed under the continuation channel and the received input --- context is split between those two. Output requires a channel capable of sending, a value to be sent, and a continuation process typed under the continuation channel --- context is split between those three. Selection requires a channel capable of selecting, a process typed under the internally selected continuation channel, and a valid selection —-- context is split between the first two. Branching requires a channel capable of branching, and for every possible external choice, a process typed under the externally chosen continuation channel --- context is split between the two.

\begin{figure}[H]
    \begin{mathpar}
    \inferrule
        { }
        {x : \type{End} \types \PO}
        \quad (\textsc{T-Inact})

    \inferrule
        {\Gamma,x:T,y:\dual{T} \types P}
        {\Gamma \types \new{x}{y}P}
        \quad (\textsc{T-Res})

    \inferrule
        {\Gamma_1 \types P \\
         \Gamma_2 \types Q}
        {\Gamma_1 \circ \Gamma_2 \types \comp{P}{Q}}
        \quad (\textsc{T-Par})

    \inferrule
        {\Gamma_1 \types x:\Recv{T}S \\
         \Gamma_2,x:S,y:T \types P}
        {\Gamma_1 \circ \Gamma_2 \types \cin{x}{y}P}
        \quad (\textsc{T-In})

    \inferrule
        {\Gamma_1 \types x:\Send{T}S \\
         \Gamma_2 \types v:T \\
         \Gamma_3,x:S \types P}
        {\Gamma_1 \circ \Gamma_2 \circ \Gamma_3 \types \cout{x}{v}P}
        \quad (\textsc{T-Out})

    \inferrule
        {\Gamma_1 \types x:\Branch{\{l_i : S_i\}_{i \in I}} \\
         \Gamma_2,x:S_i \types P_i \\
         \forall i \in I}
        {\Gamma_1 \circ \Gamma_2 \types \branch{x}{\{l_i : P_i\}_{i \in I}}}
        \quad (\textsc{T-Branch})

    \inferrule
        {\Gamma_1 \types x:\Select{\{l_i : S_i\}_{i \in I}} \\
         \Gamma_2,x:S_j \types P_j \\
         \exists j \in I}
        {\Gamma_1 \circ \Gamma_2 \types \select{x}{l_j}P}
        \quad (\textsc{T-Select})

    \end{mathpar}
    \caption{Typing rules for processes using session typed channels}
    \label{session-types-typing-rules}
\end{figure}

The reduction of session types is a byproduct of these rules, and follows the operational semantics of the \picalc{} listed in Figure \ref{picalc-reduction}: when two processes either communicate (\textsc{R-Comm}) or make a choice (\textsc{R-Case}) over linked dual channel endpoints, the \emph{head} of those channel endpoints (their first action) is consumed.

As a result of this setup, session types guarantee three properties:
\begin{description}
    \item [Communication privacy] Every channel endpoint is used exactly by one process. This applies to channels created by message input as well as by scope restriction. This property is a byproduct of the \textbf{linearity} of contexts: parallel composition splits the linear context into two disjoint unions, effectively deciding which process gets to use the endpoint.
        
    \item [Communication safety] Values sent by one process are expected by the process on the other side of the channel. This property arises as a result of \textbf{duality}: only processes that communicate over channel endpoints linked through restriction can be reduced, and restriction requires channel endpoints to have dual session types.

    \item [Session fidelity] Processes follow session types sequentially. This property is a consequence of linearity and the way in which the typing rules in Figure \ref{session-types-typing-rules} deconstruct session types by taking their continuations apart.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Coq proof assistant}\label{coq}

Coq \cite{CoqDeveloperCommunity} is a popular proof assistant and dependently typed functional language based on the calculus of inductive constructions \cite{Coquand1989} (which adds inductive data types to the calculus of constructions \cite{Coquand1985}), a type theory isomorphic to intuitionistic predicate calculus --- a constructive logic with quantified statements.  Coq features proof irrelevance for proofs (in \coqe{Prop}) and a cumulative set of universes (in \coqe{Type}).

The following example introduces some of the basic building blocks of dependent type programming. The type \coqe{Zero} (also known as $\bot$) has no constructors: there exist no programs that inhabit it. The proposition \coqe{P -> Zero} represents negation, that \coqe{P} is provably false. Conversely, from a proof of falsity one might conclude anything: \coqe{Zero -> P}, for any \coqe{P}. The dual of $\bot$ is $\top$, here represented as \coqe{One}: the trivial type that contains no information, also known as the unit type. Sigma is the existential type, or dependent tuple: for some $A$ and some predicate $P$, the first element of the tuple is an $A$; the second element of the tuple is a proof that $P$ holds for that particular $A$.

\begin{coq}
    Inductive Zero : Type :=.
    Definition neg (P : Type) : Type := P -> Zero.
    Inductive One : Type := tt.

    Inductive Sig (A : Type) (P : A -> Type) : Type :=
      sig : forall (a : A), P a -> Sig A P.
    Arguments sig {A P}.
\end{coq}

Coq is dependently typed: types can depend on --- or even contain --- programs. Since that is the case, programs in Coq must exhibit termination --- recursion must occur on structurally smaller terms. The example bellow introduces the recursive function \coqe{Even}, which given a natural number returns a type --- that is to say, it relates each natural number with a proposition, in these case capturing their evenness. Below it, a proof that uses sigma types to show that there is at least one natural number that is even.

\begin{coq}
    Fixpoint Even (n : nat) : Type :=
      match n with
      | Z         => One
      | (S Z)     => Zero
      | (S (S n)) => Even n
      end.

    Example _ : Sig nat Even := sig 42 tt.
\end{coq}

Coq allows users to build proofs using \emph{tactics}: programs written in $L_{tac}$ that manipulate hypotheses and transform goals. While these programs might be incorrect, or not terminate, their outcome is ultimately checked by \emph{Gallina}, the specification language of Coq. The example below proves for every natural number $n$ that if $n$ is even, then $n+1$ is not. It does so through the sequential application of tactics. Each tactic manipulates the goal and context of the proof (see annotations in comments). The proof proceeds by induction on $n$: the proof obligation in the base case reduces to \coqe{neg (Even (S Z))}, which by definition of \coqe{Even} reduces to \coqe{neg Zero}, that is, \coqe{Zero -> Zero}, the identity function. The inductive step is provable thanks to the fact that \coqe{Even (S (S n))} reduces to \coqe{Even n}.

\begin{coq}
    Lemma SEven0 (n : nat) : Even n -> neg (Even (S n)).
    Proof.
      (* n : nat
         --------------------
         Even n -> neg (Even (S n)) *)
      intros En ESn.

      (* n : nat 
         En : Even n
         ESn : Even (S n)
         --------------------
         Zero *)
      induction n.

      (* En : Even 0
         ESn : Even 1
         --------------------
         Zero *)
      contradiction.

      (* n : nat
         En : Even (S (S n))
         ESn : Even (S (S n))
         IHn : Even n -> Even (S n) -> Zero
         --------------------
         Zero *)
      apply (IHn ESn En).
    Qed.
\end{coq}

In Coq, simultaneously pattern matching on multiple indexed data types can be extremely clunky and arduous. The \emph{Equations} package eases this inconvenience by enabling an equational definition style, pattern matching on the left, and \texttt{with} constructs (\cite{McBride2004}), making Coq as convenient for dependent pattern matching as Agda. The theorem \coqe{SEven0} is proven again below, this time using dependent pattern matching. Coq is able to use tactics to solve the base case automatically, as \coqe{ESn} is uninhabited.

\begin{coq}
    From Equations Require Import Equations.

    Equations SEven1 (n : nat) : Even n -> neg (Even (S n)) := {
    SEven1 Z     En ESn := _ ;
    SEven1 (S n) En ESn := SEven1 n ESn En}.
\end{coq}

Coq supports inductive and coinductive data types. The constructors of an inductive data type can contain recursive references to the data type --- as long as they are strictly positive, that is, do not appear inside an argument to the left of an arrow \cite{Dybjer1994}. The type of an inductive data type can accept both parameters and indices as arguments. Parameters appear on the left hand side of the colon, indices appear on the right hand side; parameters are fixed throughout the constructors, indices may change.

The example below defines vectors: lists that keep track of their length on the type level. The parameter \coqe{A} refers to the type of elements within the list, and therefore stays fixed through the induction. However, the index (of type \coqe{nat}) changes through induction: \coqe{nil} initialises it to 0; \coqe{cons} is provided with a term of type \coqe{A} and a vector of length \coqe{n}, and results in a vector of length \coqe{n + 1}.

\begin{coq}
    Inductive Vec (A : Type) : nat -> Type :=
    | nil  : Vec A Z
    | cons : forall {n}, A -> Vec A n -> Vec A (S n)
    .
\end{coq}

The next example encodes proofs of a natural number $n$ being less than or equal to a natural number $m$. These two naturals are kept as indices in \coqe{lte}. The constructor \coqe{zlte} initialises $n$ to 0 and $m$ to any number --- 0 is less than or equal to any natural. The constructor \coqe{slte} increments both $n$ and $m$. Every proof of $n \leq m$ can thus be encoded into exactly one recursive combination of the contructors \coqe{zlte} and \coqe{slte}.

\begin{coq}
    Inductive lte : nat -> nat -> Type :=
    | zlte : forall {m}, lte Z m
    | slte : forall {n m}, lte n m -> lte (S n) (S m)
    .
\end{coq}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Design}\label{design}

This chapter describes how our encoding of the session-typed \picalc{} into Coq works. This encoding only handles session-typed channels, specifically channels with finite (non-replicating, non-recursive) session types. The encoding has no intermediary models --- for instance, the polarised linear \picalc{}. The main characteristic of our design is the use of function abstraction to pass around both messages and channels (see \S \ref{overview}). Alternative approaches are listed in \S \ref{related-work}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview}\label{overview}

Our design is based on \emph{continuation passing}, where channels are \textbf{used exactly once}: channels get destroyed and created with every action taken by a process. This approach has its origin in the encoding of session types into the polarised linear \picalc{} \cite{Kobayashi1999, Dardha2012, Dardha2016}: session-typed channels are transformed into single-use polarised channels, each containing the type of data being transmitted and the encoding of the channel's continuation. For instance, the session type $\Send{A} \Recv{B} \End$ is encoded as $\ell_o [A,\ell_i [B,\ell_\emptyset []]]$ where $\ell_i [A, Cont]$ is a single-use channel signifying input $A$, then continue as $Cont$ --- and similarly for output. When a process uses a channel with such a type to communicate, that channel gets destroyed, the \emph{head} of the channel's type is consumed, and a new channel with the \emph{tail} of the type ($\ell_i [B, \ell_\emptyset []]$) is created.

The main characteristic of our design is the use of a higher order abstract syntax to lift binding of channels and messages in the object language into bindings in the host language. This approach offers several advantages, but it also creates several challenges that must be addressed:

\todo{We do not do open processes}

\paragraph{Advantages}
\begin{enumerate}
    \item \emph{The user can refer naturally to both messages and channels}

    Our approach lifts all variable references into Coq. The example session-typed \picalc{} process bellow has two branches: one that outputs \coqe{true} and receives some \coqe{m}; the other that receives some \coqe{m} and outputs that same \coqe{m}. Note that \coqe{m} gets bound as a variable in Coq. Alternative approaches that encode variable references in the object language itself need to use de Bruijn indices \cite{deBruijn1972} or similar techniques, resulting in a processing overhead for users.
        
    \begin{coq}
    Example example2 : PProcess := ([v]>
        (new o <- ! B[bool] ; ? B[bool] ; ø,
             i <- ? B[bool] ; ! B[bool] ; ø,
             ltac:(auto))
        (o![v _ true]; ?[m]; $\epsilon$) <|> i?[m]; ![m]; $\epsilon$).
    \end{coq}

    \item \emph{There is no need for machinery that avoids variable capture}

        \todo{Explanation}

    \item \emph{There is no need for substitution lemmas}

        \todo{Explanation}
\end{enumerate}

\paragraph{Problems}
\begin{enumerate}
    \item \emph{Channels can be manufactured outside the calculus}

    The \picalc{} provides two ways to obtain a channel: by using scope restriction, and by receiving a message that contains a channel. The user must be restricted to use these constructs. If the type of channels is defined inductively, the user is not prevented from forging channels. Our solution to this problem is to parametrise processes with an unknown channel type, and to define our calculus and its theorems parametrised by this unknown type. \S \ref{polymorphism} covers our solution in depth.

    \item \emph{The type of messages must be tracked}

    The \picalc{} allows messages to contain both terms of a given base type, and channels of a given session type. Messages must track information about the type of their content. Moreover, this information must be kept at the type level, so that the typechecker is able to verify that processes make correct use of messages. Dependent types allow session types to be defined as an inductive type, and to then index the type of messages by the type of value they contain --- whether this is a session type or a base type. See \S \ref{messages} and \S \ref{processes} for more details.

    \item \emph{Channels can be used more than once, or not used at all}

    Our approach encodes session-typed channels as single-use channels that are created and destroyed with every action taken by a process. To invoke these actions, an appropriate session-typed channel has to provided. The action then use function abstraction to provide an environment in which a channel with the tail of the original session type is received as an argument. This channel passed as an argument must be used exactly once. Unfortunately, Coq has no support for linearity, and thus this property has to be checked ad-hoc. How to do this is covered in \S \ref{linearity}.

    \item \todo{introduce congruence and reduction}
\end{enumerate}

The next sections cover the different components that make up our encoding. We start with type definitions and defining the notion of duality of session types (\S \ref{types}). We then encode messages and processes (\S \ref{processes}), for which we define a linearity predicate (\S \ref{linearity}) to ensure that they are well-typed. Finally, we define structural congruence (\S \ref{structural-congruence}) and reduction (\S \ref{reduction}), and we then prove that reduction preserves linearity, and hence well-typedness.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Types}\label{types}

We start by defining \coqe{MType} (the type of messages) and \coqe{SType} (the types of channels) by mutual induction, as messages can contain channels and channels can send and receive messages. This definition encodes type type grammar in Figure \ref{session-types-grammar}. We admit every Coq \coqe{Type} as a base type: anything can be sent over a channel. We use vectors for branching and selection so that we can keep track in the types of the number of options available.

\coqi[3-14]{../src/Types.v}

Coq does not directly admit misfix notation like Agda does, and so we need to introduce convenient notation separately:

\coqi[16-21]{../src/Types.v}

We then introduce the notion of duality of session types, modelling the definition in Figure \ref{session-types-duality} through an inductive proposition. The constructor suffixes \coqe{Right} and \coqe{Left} signify the direction of information flow. For branching and selection, we require both option vectors to be of the same length, and for every ith selection option and every ith branching option to be dual --- \coqe{Forall2 Duality xs ys} encodes evidence that that is the case. 

\coqi[23-31]{../src/Types.v}

Finally, we prove that duality is commutative by providing a recursive program of the type \coqe|duality_comm {s r : SType} (d : Duality s r) : Duality r s|.

\paragraph{Examples.}
The examples bellow introduce several session types using the aforementioned notations. We then prove that \coqe{type1} and \coqe{type2} are dual, while \coqe{type1} and \coqe{type3} are not. These proofs execute specialised tactics which are found in a hint database by \coqe{auto}.

\coqi[12-16]{../src/Examples.v}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Polymorphic messages}\label{polymorphism}

Programs that depend on unconstrained types are said to be parametrically polymorphic. Terms inhabiting those types cannot possibly be constructed or eliminated by pattern matching, and are therefore said to be \emph{opaque}. In a purely functional language like Coq, programs of an unconstrained polymorphic type give rise to important theorems that stem purely from the polymorphism of the type \cite{Wadler1989}.

In our project, we parametrise several inductive definitions with polymorphic types. We do so by using the \coqe{Section Processes.} directive, instructing Coq to parametrise with parameters \coqe{ST} and \coqe{MT} all the definitions within the section. These variables are then only used by the inductive type \coqe{Message}, which is in turn used by other several definitions within the section. The type \coqe{Message} captures the values sent between processes, and is indexed by the type of the value being sent. The two constructors \coqe{V} and \coqe{C} construct values of a given base type and channels of a given session type, respectively.

\coqi[6-13]{../src/Processes.v}

The linearity predicate introduced in \S \ref{linearity} is defined recursively on processes. Processes (\S \ref{processes}) contain functions that take messages as arguments and return processes; to be able to traverse processes where message passing is modelled as function abstraction, one has to be able to provide messages of any given type:
\begin{description}
    \item [Messages containing channels] The \coqe{C} constructor expects a token of the undefined type \coqe{ST}. Channels cannot be constructed as long as the type \coqe{ST} is made concrete. This prevents channels from being built outside of the operations provided by the calculus. To traverse a process, it is enough to set \coqe{ST} to the unit type, or any other type that can be constructed.
        
    \item [Messages containing base types] The \coqe{V} constructor expects a value of the undefined type \coqe{MT M}: \coqe{M} represents the type of the value sent as a message; \coqe{MT} serves as a projection function from types to types. If \coqe{MT} is set to \coqe{id}, then a value of type \coqe{M} must be provided; if \coqe{MT} is set to the projection \coqe{fun t => unit}, then a value of the unit type will be demanded instead. This makes messages always constructable, and therefore processes always traversable. 
\end{description}

The users define processes without knowledge of the concrete instantiation of \coqe{ST} and \coqe{MT}. As a result, they have no information about the type \coqe{MT M} required to build messages of type \coqe{B[M]}. To remedy this, \coqe{PProcess} is provided the assumption \coqe{mt}: for any type \coqe{S}, no matter what \coqe{MT} is, a message of base type \coqe{S} can be constructed. Processes can use this assumption to create messages out of Coq terms. For convenience, we introduce a shortcut that ignores \coqe{ST} and \coqe{MT}:

\coqi[139-142]{../src/Processes.v}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Processes}\label{processes}

We encode processes into a higher order abstract syntax where messages are parametric. Higher order abstract syntaxes use binders in the host language to encode binding in the object language \cite{Chlipala2008}. Here, we use it both to bind incoming messages, and to bind channels generated as a result of continuation passing. The constructors of the \coqe{Process} type are in one to one correspondence with typing rules for session types found in Figure \ref{session-types-typing-rules}. In this section we will argue that, \textbf{provided all channels are used exactly once, these constructors allow only correct processes to be built}. The assumption that all channels are used exactly one is later discharged on the linearity predicate defined on processes (\S \ref{linearity}).

We start defining process termination (\textsc{T-Inact}), which requires exactly one channel to be in context, and for that channel to have the session type \End. The constructor \coqe{PEnd} requires a single argument: a channel with session type \End. The linearity predicate guarantees that all other channels in Coq's context are used.

\coqi[18-19]{../src/Processes.v}

Scope restriction (\textsc{T-Res}) adds two channels of dual types to the context. The constructor \coqe{PNew} expects two session types, a proof of their duality, and a function that uses channels of those two session types to type a process. The linearity predicate needs to ensure that these channels are used.

\coqi[21-25]{../src/Processes.v}

Parallel composition (\textsc{T-Par}) expects two subprocesses. The linearity predicate needs to ensure that the context is split between these two processes.

\coqi[27-27]{../src/Processes.v}

Input (\textsc{T-In}) requires a channel of type $\Recv{T}S$, and a process where the continuation channel $x$ of type $S$ and the input $y$ of type $T$ are put in context. The \coqe{PInput} constructor uses function abstraction to model the addition of $x$ and $y$ to the context. The linearity predicate needs to ensure that context is split between these two premises, and that the consumed channel cannot be used again.

\coqi[29-33]{../src/Processes.v}

Similarly, output (\textsc{T-Out}) requires a channel of type $\Send{T}S$, a message of type $T$, and a process where the continuation channel $x$ of type $S$ is put in context. The \coqe{POutput} constructor uses function abstraction to model the addition of $x$ to the context. The linearity predicate needs to ensure that context is split between these three premises, and that the consumed channel cannot be used again.

\coqi[35-40]{../src/Processes.v}

Branching (\textsc{T-Branch}) requires a channel of type $\Branch \{l_i : S_i\}_{i \in I}$, and for each continuation channel $x : S_i$, a process where $x$ is put in context. The \coqe{PBranch} constructor requires a channel capable of branching on a vector of session types. For each of those session types, a process where a channel of the given session type is put in context is demanded --- again, this is modelled through function abstraction. The linearity predicate needs to ensure that context is split between the two premises, and that the consumed channel cannot be used again.

\coqi[42-46]{../src/Processes.v}

Selection (\textsc{T-Select}) requires a channel of type $Select \{l_i : S_i\}_{i \in I}$, a choice $j$, and a process where the continuation channel $x : S_j$ is put in context. The \coqe{PSelect} constructor uses finite sets to ensure that the choice is a valid one, and function abstraction to model the addition of a channel of the chosen session type to the context. The linearity predicate needs to ensure that context is split between the two premises, and that the consumed channel cannot be used again.

\coqi[48-52]{../src/Processes.v}

To make things easier for the end user, we provide convenient notations for process constructors:

\coqi[158-173]{../src/Processes.v}

\paragraph{Examples.} Bellow is a simple process definition that creates two channel endpoints \coqe{o} and \coqe{i}, and composes in parallel two processes that exchange a boolean value back and forth, and then end. Note the use of tactics to prove the duality of the channels. The function $\upsilon$ is used to \emph{lift} the boolean value \coqe{true} into a message.

\coqi[18-20]{../src/Examples.v}

The next example showcases type inference for session types. We introduce to parallel processes in where the session types for the channels \coqe{i} and \coqe{o} are left undefined. We use the tactic \coqe{refine} to leave the proof of their duality undefined as well, as it is yet too early to know about the types of \coqe{i} and \coqe{o}. Once the process bodies force their type, we are able to provide a proof of their duality with \coqe{auto}.

\coqi[22-27]{../src/Examples.v}

When we print the defined process, we can see that Coq has automatically deduced the required session types for \coqe{i} and \coqe{o}:

\begin{coq}
example2 = 
fun (ST : Type) (MT : Type -> Type) (υ : forall S : Type, S -> Message ST MT B[ S]) =>
(newi <- ? B[ bool]; ! B[ bool]; ø, o <- ! B[ bool]; ? B[ bool]; ø,
MLeft (MRight Ends)) i ?[ m ]; (![ m ]; ε) <|> o ![ υ bool true ]; (?[ _ ]; ε)
     : PProcess
\end{coq}

Finally, the example bellow demonstrates channel mobility (a channel that is sent over another channel):

\coqi[57-64]{../src/Examples.v}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Structural congruence}\label{structural-congruence}

\todo{confirm that symmetry is not neeed}
\todo{we do not define contexts separately, we introduce reflexivity and transitivity in the same datatype}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Reduction}\label{reduction}

We use an inductive family of types to describe the reduction rules (listed in Figure \ref{picalc-reduction}, extended with session types in \S \ref{session-types}) of session-typed \picalc{} processes. The data type is indexed by two processes: the former is the redex, the latter the reduction target. 

\coqi[100-101]{../src/Processes.v}

The \coqe{RComm} constructor expects two channel endpoints created as a result of scope restriction to be used by two parallel processes: one that outputs \coqe{m} and continues as \coqe{Q}, the other that expects input in \coqe{P}. The reduction creates a new scope restriction, and puts in parallel a process with the continuation \coqe{Q} and the process \coqe{P} fed with the input \coqe{m}. Note that this encoding works thanks to Coq's ability to pattern match on the body of functions.

\coqi[102-106]{../src/Processes.v}

Similarly to \coqe{RComm}, the \coqe{RCase} constructor transmits choice from one process to the other. Note, however, that thanks to the typing rules for the constructors \coqe{PBranch} and \coqe{PSelect}, the vectors \coqe{Ps} and \coqe{Qs} are guaranteed to be of the same length, and the choice \coqe{i} is guaranteed to be a valid index within the vectors. We therefore just need to select the \coqe{i}th vector of \coqe{Qs} as the continuation process after reduction.

\coqi[108-113]{../src/Processes.v}

The last three constructors are inductively defined, and serve to encode that reduction goes under scope restriction and parallel composition, and that reduction is defined up to structural congruence.

\coqi[115-126]{../src/Processes.v}

Lastly, we define an inductive type family that encodes big step reduction (reduction in zero or more steps):

\coqi[128-133]{../src/Processes.v}

\paragraph{Examples.}

The following example defines the process \coqe{Example3}, and proves that \coqe{Example2} introduced in \S \ref{processes} reduces in one step to \coqe{Example3}. The reduction proof uses a specialised tactic executed by \coqe{auto} by searching through a hint database. The tactic is in itself incomplete: reduction might make use of zero or more steps of structural congruence rewriting, resulting in a wide search space. If the automatic tactic fails, the user is still able to provide an explicit proof of reducibility.

\coqi[32-36]{../src/Examples.v}

The next example goes further and shows that \coqe{Example2} reduces to \coqe{Example5} (a final irreducible value) in zero or more steps:

\coqi[44-47]{../src/Examples.v}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Linearity}\label{linearity}

The process constructors introduced in \S \ref{processes} rely on a linearity predicate that makes sure that every created channel is used exactly once. We define this proposition by induction on processes, in particular processes where the type for channels (\coqe{ST}) is a boolean, and the function on message types (\coqe{MT}) is a projection to the unit type. The idea is to mark each newly created channel in turn (by setting it to \coqe{true}), and to then check that exactly one marked channel is found in the subprocesses.

\coqi[8-9,95-95]{../src/Linearity.v}

The predicate \coqe{lin} is defined by mutual recursion with \coqe{single_x}. Both predicates use the Equations package to dependently pattern match on channel types.
\begin{itemize}
    \item \coqe{lin (P: Process bool TMT) : Prop} recursively checks that if all newly created channels are unmarked, no marked channels are found. For every newly created channel, it also checks that marking the channel while leaving the rest unmarked results in \coqe{single_x} finding a single marked channel.  

    \item \coqe{single_x (P : Process bool TMT) : Prop} recursively checks that if newly created channels are unmarked, a single marked channel is found. Once that channel is found, it uses \coqe{lin} to check that continuing down recursively finds no marked channels. Worth nothing is the case of parallel composition, where \coqe{single_x} checks that \coqe{(lin P /\ single_x Q) \/ (single_x P /\ lin Q)}, that is, the marked channel must be in either \coqe{P} or \coqe{Q}, but not in both.
\end{itemize}


\paragraph{Examples.}

The next two examples (of example processes defined in \S \ref{processes}) introduce a tactic that proves that the process uses channels linearly. This tactic is called by \coqe{auto} through its hint database.

\coqi[77-78]{../src/Examples.v}

As a counterexample, we introduce a process for which we prove that its use of channels is \emph{not} linear.

\coqi[80-86]{../src/Examples.v}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Subject reduction}\label{subject-reduction}

As shown in \S \ref{processes}, assuming that channels are used linearly, process constructors are accurate enough to rule out ill-typed processes by construction. Here, we show that well-typedness is preserved through reduction, i.e. that linearity is preserved through reduction: if $P$ reduces to $Q$ and $P$ is linear (well-typed), then $Q$ is linear (well-typed) as well:

\coqi[80-80]{../src/SubjectReduction.v}

\coqi[95-95]{../src/SubjectReduction.v}

As linearity is defined on processes where channels are represented as booleans and message types are projected to the unit type (\S \ref{linearity}), proofs that show that linearity is carried through reduction need to specialise their processes. The proofs themselves are by induction on processes. To make the induction hypothesis stronger, proofs show that both linearity and the presence of a marked channel are preserved.

\coqi[64-65]{../src/SubjectReduction.v}

Reduction has two cases in need of special attention: case selection (\textsc{RCase}) has to show that if an entire set of branches is considered to be linear, then so is any specific branch in that set; structural congruence (\textsc{RStruct}) needs to show that linearity is preserved through congruence too. Again, we strengthen the induction hypotheses for these lemmas with assertions of single marked channel preservation.

\coqi[34-35]{../src/SubjectReduction.v}

\coqi[48-52]{../src/SubjectReduction.v}

\paragraph{Examples.}
We can apply the proof of linearity preservation through reduction to specific processes. The example bellow proves that any process that \coqe{example1} reduces to in zero or more steps must make a linear use of channels.

\coqi[51-55]{../src/Examples.v}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Alternative approaches and related work}\label{related-work}

Unfortunately, the approach in point (i) makes it impossible for processes to use any logic that is external to the calculus and depends on the type of messages. An alternative approach for simulating linearity is by doing it \emph{a priori}, at construction time, by keeping track of the linearly available channels through a context by which processes are indexed.  This means that channel creation cannot be represented through function abstraction, that process composition needs to explicitly split the context, and that there must be a way of addressing a particular channel within a context --- strings with the Barendregt convention \cite{Barendregt1984}, De Bruijn indices \cite{deBruijn1972}, locally nameless De Bruijn indices, or a parametric HOAS \cite{Chlipala2008} --- since only channels need to be used linearly, message input can still be represented as function abstraction whenever the message does not contain a channel. On the bright side, this approach allows processes to use logic that external to the calculus and depends on the types of messages.

While the latter approach has more appealing properties, its mechanics negatively affect usability: can it be equipped with the usability of the former approach? I intend to create a Coq library that abstracts away the simulation of linearity.

\paragraph{Using de Bruijn indices}

\paragraph{Adding shared channels}
\todo{fixme}
Other efforts in formalising session types in Coq have created object languages and handled variable references, typing contexts, and typing judgments by hand \cite{Dilmore2019}.

Linearity is strongly connected to session types: a session type must transition through each of its stages \emph{exactly} once. Session types can be encoded into a \picalc{} with linear types, as shown by \cite{Kobayashi1996,Dardha2012,Dardha2016}. As shown in \cite{Voinea}, in systems where session types are shared, the tokens allowing access to the session-typed channels must still be linear.

In type systems with no linear types the linearity of channels has to be simulated. In these type systems, modelling channels through a parametric higher order abstract syntax \cite{Chlipala2008} is not possible per se: the host language is unable to check whether the channels passed along as arguments are used linearly. This means that typing judgments must happen at the object language, through the use of a context that keeps track of linear resources.  This context is usually tracked at the type level, using inductive \emph{families} \cite{Dybjer1994} indexed by a context of linear resources \cite{Power2000} --- though there are approaches that keep track of context through type-classes and use monadic binding to embed a linear calculus within non-linear hosts \cite{Paykin2017}.

The \picalc{} has been an extensive subject of machine verification: \cite{Henry-Gerard1999} proofs subject reduction for it; \cite{Despeyroux2000} proofs subject reduction as well, but uses a higher order syntax; \cite{Affeldt2008} provides proofs of fairness and confluence; \cite{Honsell2001} formalises the bisimilarity proofs found in \cite{Walker1989}; \cite{Gay2001} provides a framework for formalisation on the \picalc{} with linear channels in Isabelle/HOL.

In \cite{Xi2016} session types are formalised in ATS, providing type preservation and global progress proofs. \cite{Bock2016} uses Celf to represent session types in intuitionistic linear logic.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Results and conclusion}\label{conclusion}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\small
\bibliographystyle{alpha}
\bibliography{mproj}
\end{document}
