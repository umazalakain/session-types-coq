\documentclass{mproj}

\usepackage[utf8]{inputenc}

% Coq code
\usepackage[dvipsnames]{xcolor}
\usepackage{listings}
\input{lstcoq.sty}

% Math
\usepackage{amsmath}
\usepackage{amssymb}

% Use times font
\usepackage{times}

% They are all over the place
\usepackage{todonotes}

% Allows to place figures HERE!
\usepackage{float}

% Enums
\usepackage{enumitem}
\setlist{nolistsep}

% Inference rules
\usepackage{mathpartir}

% Links and their colors
\usepackage{url}
\usepackage[
  colorlinks=true,
  linkcolor=darkgray,
  citecolor=darkgray,
  urlcolor=darkgray,
  ]{hyperref}

\usepackage{titlesec}
% Use a single line for chapter headers
\titleformat{\chapter}[hang]{\normalfont\huge\bfseries}{\thechapter.}{1em}{} 
% Remove the space before chapter titles
\titlespacing*{\chapter}{0pt}{0pt}{40pt}

% Appendices
\usepackage[header,title,titletoc]{appendix}
\renewcommand{\appendixname}{Appendix}

% License
\usepackage[
    type={CC},
    modifier={by-sa},
    version={3.0},
]{doclicense}

\usepackage[many]{tcolorbox}
\newtcolorbox{thesis-statement}[1]{%
    tikznode boxed title,
    enhanced,
    arc=0mm,
    interior style={white},
    attach boxed title to top center= {yshift=-\tcboxedtitleheight/2},
    fonttitle=\bfseries,
    colbacktitle=white,coltitle=black,
    boxed title style={size=normal,colframe=white,boxrule=0pt},
    title={#1}}

% Add bibliography to TOC
\usepackage[nottoc,numbib]{tocbibind}

\newtheorem{theorem}{Theorem}

% Commands for the pi-calculus
\newcommand{\PO}{\mathbf{0}}
\newcommand{\comp}[2]{#1 \mid #2}
\newcommand{\new}[2]{(\boldsymbol{\nu} #1 #2) \;}
\newcommand{\cout}[2]{\overline{#1}\langle#2\rangle.}
\newcommand{\cin}[2]{#1(#2).}
\newcommand{\select}[2]{#1\triangleleft#2.}
\newcommand{\branch}[2]{#1\triangleright#2}
\newcommand{\subst}[3]{#1[#2/#3]}
\newcommand{\picalc}{$\pi$-calculus}
\newcommand{\Picalc}{$\pi$-Calculus}
\newcommand{\type}{\texttt}
\newcommand{\End}{\type{End}}
\newcommand{\Send}[1]{!#1.}
\newcommand{\Recv}[1]{?#1.}
\newcommand{\Select}{\oplus}
\newcommand{\Branch}{\&}
\newcommand{\dual}{\overline}
\newcommand{\reduce}{\rightarrow}
\renewcommand{\emptyset}{\varnothing}
\newcommand{\types}{\vdash}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Type-checking\\ session-typed \picalc \\ with Coq}
\author{Uma Zalakain}
\date{2019-09-06}
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
\todo{go over this again}
    This project formalises the session-typed \picalc{} in Coq using a mix of continuation passing, parametric HOAS, dependent types and ad-hoc linearity checks. Each action a process takes requires a channel capable of that action. The head of that channel's type is then stripped off and its continuation is passed to the next action the process takes. Dependent types guarantee this continuation passing is correct by construction. The type of channels is parametrised over, so that users are unable to skip the proper mechanisms to create channels. The HOAS makes the syntax easy to use for both the end user and the designer: all variables are lifted to Coq, no typing contexts are required. The continuation passing always creates channels that must be used exactly once, but unfortunately Coq has no support for linearity, so this check needs to happen ad-hoc, by traversing processes. Ultimately, the claim is this: if the definition of a process typechecks in Coq, and the process uses channels linearly, then type safety and type preservation through reduction hold.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\educationalconsent
\vfill{}
\doclicenseThis
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgements}

Acknowledgements go here

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}\label{intro}

During the last decades, while the frequency at which processors run has peaked, the number of available processing units has kept growing. Computing has consequently shifted its focus into making processes safely communicate with one another --- no matter if they run concurrently on different CPU cores or on different hosts. The interest in the formalisation and verification of \emph{communicating concurrent} systems (where processes share no state and change as communication occurs) has grown as a result.

Communicating concurrent processes must satisfy some safety properties, such as following a pre-established communication protocol (where all messages sent by one process are expected by the other and vice versa) or communicating over private channels only known to the involved participants. To make properties like these easier to prove, formal models such as the \emph{\picalc{}} \cite{Walker1989,Milner1989,Milner1991,Sangiorgi2001} abstract real-world systems into suitable mathematical representations. \S \ref{pi-calculus} provides a brief overview of the \picalc.

The properties of a formal system can be verified either \emph{dynamically}, by monitoring processes at runtime, or \emph{statically}, by reasoning on the definition of the processes themselves.  Static guarantees --- while harder to define and sometimes more conservative than dynamic ones --- are \emph{total}, and thus satisfied regardless of the execution path. The basis of static verification is comprised of \emph{types} and \emph{type systems}, which are also the basis of programming languages and tools, making type-based verification techniques transferable to practical applications. An example of this are the plethora of types for communication and process calculi: from standard channel types, as found in e.g., Erlang or Go, to \emph{session types} \cite{Honda1993, Takeuchi1994, Honda1998}, a formalism used to specify and verify communication protocols (more in \S \ref{session-types}).

\todo{move session type definition and properties up here?}

The mechanised formalisation and verification of programming languages and calculi is an ongoing community effort in securing existing work: humans are able to check proofs, but they are very likely to make mistakes; machines can verify proofs mechanically. A remarkable example of a community effort towards machine verification is RustBelt \cite{Dreyer2018}, a project that aims to formalise and machine-check the ownership system of the programming language Rust with the help of separation logic \cite{} and the proof assistant Coq. Not only does mechanisation increase confidence in what is mechanised, but also in all other derived work that is yet unverified: proving the correctness of Rust's type system immediately increases the confidence in all software written in it.

\begin{thesis-statement}{THESIS STATEMENT}
    This project formalises the \emph{session-typed \picalc{}} in such a way that variable references in the object language are lifted into variable references in the host language. The use of channels in the object language is then restricted to be linear, ensuring \emph{communication privacy}, \emph{communication safety} and \emph{session fidelity} (refer to \S \ref{session-types-properties}). Lastly, we machine-verify \emph{subject reduction} for the resulting language.
\end{thesis-statement}

\todo{mention we have no shared channels and no recursive session types}

We choose Coq \cite{Coquand1989, CoqDeveloperCommunity} to machine-verify the session-typed \picalc{}, mainly due to its widespread use as a proof assistant (refer to \S \ref{coq} for an overview). A first challenge with Coq is that it offers \emph{no} support for \emph{linearity}, which is at the very heart of session types (as communication occurs, a session type must transition through each of its stages exactly once). As a result, extra work is required to simulate the linearity of the terms in the object language.

The present work simulates linearity by defining it as an inductive predicate on processes (\S \ref{linearity}). Once such a predicate establishes that a process uses channels linearly, the use of channels according to their specification is guaranteed by construction. References to both channels and messages are lifted into the host language, making the resulting syntax amicable to the user. As a consequence of this approach the object language requires \emph{no typing contexts} and \emph{no substitution lemmas}.

Other approaches to formalising process calculi are briefly exposed in \S \ref{related-work}. Closing, \S \ref{conclusion} suggests future work that might be of interest, and offers conclusions on what this project has achieved.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Background}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\picalc}\label{pi-calculus}

\paragraph{Scope} This section provides an overview of the \picalc{} as introduced in \cite{Sangiorgi2001}. However, it deliberately ignores replication and indeterministic choice, features part of the \picalc{} that are not covered by this project. Additionally, and as preliminary preparation for the introduction of session types, this section defines channel restriction by introducing two channel \emph{endpoints}, instead of the usual single variable used for channels.

The \picalc{} \cite{Walker1989,Milner1989,Milner1991,Sangiorgi2001} models processes that progress and change their structure by using \emph{channels} to communicate with one another. The \picalc{} features \emph{channel mobility}, which allows channels to be sent over channels themselves. In the \picalc{} any number of processes can communicate over a channel. While the \picalc{} can be typed, the type of a channel does \emph{not} evolve as communication occurs: it only specifies the type of data sent over it. An overview of the FAQs can be found in \cite{Wing2002}.

The syntax of the \picalc{} is given by the grammar in Figure \ref{picalc-syntax}. Inaction denotes the end of a process, and has therefore no continuation. Scope restriction creates a new communication channel between endpoints $x$ and $y$, which are bound in $P$. Output sends $u$ over the channel endpoint $x$, and then continues as $P$. Input waits to receive $u$ on the endpoint $y$; upon reception $u$ is bound in $P$. Selection sends the choice of process $l_j$ over $x$, and then continues as $P$. Branching offers choices over $I$, where the choice $l_i$ selects the continuation process $P_i$. Parallel composition runs processes $P$ and $Q$ in parallel, allowing these processes to communicate over shared channels.

\begin{figure}[H]
    \begin{align*}
    P,Q ::= \; &\PO                      & \text{inaction}             \\
               &\new{x}{y}P              & \text{scope restriction}    \\
               &\cout{x}{u}P             & \text{output}               \\
               &\cin{y}{u}P              & \text{input}                \\
               &\select{x}{l_j}P         & \text{selection}            \\
               &\branch{x}
               {\{l_i : P_i\}_{i \in I}} & \text{branching}            \\
               &\comp{P}{Q}              & \text{parallel composition}
    \end{align*}
    \caption{Grammar describing the syntax of the \picalc{}}
    \label{picalc-syntax}
\end{figure}

The syntax of the \picalc{} captures undesired syntactical properties of processes (e.g. associativity should not matter when three processes are composed in parallel). Structural congruence is introduced as a way to abstract over these unintended differences in syntax. It is defined by the smallest congruent equivalence relation that satisfies the inference rules in Figure \ref{picalc-congruence} -- a congruent equivalence relation in itself is the smallest relation that is reflexive, symmetric, transitive and congruent. Worth noting is the structural congruence rule for scope expansion: the scope of bound variables can include or exclude a process at will, as long as the bound variables do not appear free in that process. The congruence rule states that if two processes considered equal are placed within a common context, then the resulting contexts are equal as well (a context is a process where some occurrence of $\PO$ is substituted by a \emph{hole} that can then be filled in with a process). Said otherwise, structural congruence \emph{goes under} the syntactic constructs of the \picalc{}.

\begin{figure}[H]
    \begin{mathpar}
    \inferrule
        { }
        {\comp{P}{Q} \equiv \comp{Q}{P}}
        \quad (\textsc{C-CompComm})

    \inferrule
        { }
        {\new{x}{y} \new{z}{w} P \equiv \new{z}{w} \new{x}{y} P}
        \quad (\textsc{C-ScopeComm})

    \inferrule
        { }
        {\comp{P}{\PO} \equiv P}
        \quad (\textsc{C-Comp0})

    \inferrule
        { }
        {\comp {(\comp{P}{Q})} {R} \equiv \comp {P} {(\comp{Q}{R})}}
        \quad (\textsc{C-CompAssoc})

    \inferrule
        { }
        {\new{x}{y} \PO \equiv \PO}
        \quad (\textsc{C-Scope0})

    \inferrule
        { }
        {\new{x}{y}P \equiv \new{y}{x}P}
        \quad (\textsc{C-ScopeSwap})

    \inferrule
        {x,y \not\in fn(Q)}
        {\comp {(\new{x}{y}P)} {Q} \equiv \new{x}{y} \comp{P}{Q}}
        \quad (\textsc{C-ScopeExp})

    \end{mathpar}
    \caption{Structural congruence rules for the \picalc{}}
    \label{picalc-congruence}
\end{figure}

Computation for \picalc{} progresses is specified by reduction rules, defined in Figure \ref{picalc-reduction}. Two parallel processes communicating over the same channel (by using opposite endpoints to send and receive a message) get reduced to the parallel composition of their continuations, with the continuation of the receiving process having all the references to the message substituted by the message term itself (\textsc{R-Comm}). Similarly, a process that makes a choice put in parallel with a process that offers a choice gets reduced to the continuation of the choosing process and the chosen continuation of the process offering the choice -- so long as the choice itself is valid (\textsc{R-Case}). Reduction goes under both restriction (\textsc{R-Res}) and parallel composition (\textsc{R-Par}), but not under output, input, selection or branching -- constructs that impose order in the communication. Lastly, reduction is defined up to structural congruence: any amount of syntax rewriting can be performed before and after reduction  (\textsc{R-Struct}).

\begin{figure}[H]
    \begin{mathpar}
    \inferrule 
        { }
        {\new{x}{y}(\comp {\cout{x}{a}P} {\cin{y}{b}Q}) \reduce
         \new{x}{y}(\comp {P}            {\subst{Q}{a}{b}})}
        \quad (\textsc{R-Comm})

    \inferrule
        {j \in I}
        {\new{x}{y}(\comp {\select{x}{l_j}P} {\branch{y}{\{l_i : Q_i\}_{i \in I}}}) \reduce
         \new{x}{y}(\comp {P} {Q_j})}
        \quad (\textsc{R-Case})

    \inferrule
        {P \reduce Q}
        {\new{x}{y}P \reduce \new{x}{y}Q}
        \quad (\textsc{R-Res})

    \inferrule
        {P \reduce Q}
        {\comp{P}{R} \reduce \comp{Q}{R}}
        \quad (\textsc{R-Par})

    \inferrule
        {P \equiv P' \\ P' \reduce Q' \\ Q' \equiv Q}
        {P \reduce Q}
        \quad (\textsc{R-Struct})
    \end{mathpar}
    \caption{Reduction rules for the \picalc{}}
    \label{picalc-reduction}
\end{figure}

As an example, Figure \ref{picalc-example} creates two linked channel endpoints $x$ and $y$ and then composes two processes in parallel: one that uses $x$ to send integers $3$ and $4$, and then expect a response bound as $r$, do some $P$, then end; another that uses $y$ to receive $a$ and $b$, then send $a+b$, then end. Both processes communicate with one another when composed in parallel, changing their structure.

\begin{figure}[H]
    \begin{align*}
    \new{x}{y} (\comp{\cout{x}{3} \cout{x}{4} \cin{x}{r} P. \PO &}
                     {\cin{y}{a} \cin{y}{b} \cout{y}{a+b} \PO})
    \reduce
    \\
    \new{x}{y} (\comp{\cout{x}{4} \cin{x}{r} P. \PO &}
                     {\cin{y}{b} \cout{y}{3+b} \PO})
    \reduce
    \\
    \new{x}{y} (\comp{\cin{x}{r} P. \PO &}
                     {\cout{y}{3+4} \PO})
    \reduce
    \\
    \new{x}{y} (\comp{\subst{P}{3+4}{r}. \PO &}
                     {\PO})
    \equiv
    \\
    \subst{P}{3&+4}{r}
    \end{align*}
    \caption{Example process in the \picalc{}}
    \label{picalc-example}
\end{figure}

The grammar for the \picalc{} allows well-formed processes with no semantic meaning (e.g. $\new{x}{y} \comp {\cout{x}{true}\PO} {\cin{y}{u}(u+3).\PO}$). The syntax rules for the construction of \picalc{} terms can be refined to discard some of these constructs. One such refinement are shared types (Figure \ref{picalc-shared-types}), which ensure that the types of channels and messages match -- in the example in Figure \ref{picalc-example}, channel endpoints $x$ and $y$ would need to be of the shared base type \type{Int} for the processes to be well-typed. The formation of \picalc{} terms can be further restricted with \emph{session types}: types that serve to specify communication protocols.

\begin{figure}[H]
    \begin{align*}
    T ::= \; &\type{Chan}[T] & \text{channel type} \\
             &\ldots         & \text{base type}
    \end{align*}
    \caption{Shared types for the \picalc{}}
    \label{picalc-shared-types}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Session types}\label{session-types}

\todo{Can be binary (diadic) or multiparty}

Session types \cite{Honda1993, Takeuchi1994, Honda1998} are sequences of actions, each representing the type and the direction of the data exchanged.  Processes must use session-typed channels according to their specified protocol.  Instead of being shared and static, session types are linear, private to the communicating processes, and change as communication occurs. A comprehensive introduction to session types can be found in \cite{Vasconcelos2009}, while answers to FAQs are compiled in \cite{Dezani-ciancaglini2010}. The process above introduced as an example of the \picalc{} would have the session-types of its channels evolve through communication as follows (\type{!} denotes sending, \type{?} receiving):
\begin{align*}
x : \type{\Send{Int}\Send{Int}\Recv{Int}\End} &,\;
y : \type{\Recv{Int}\Recv{Int}\Send{Int}\End}
\reduce
\\
x : \type{\Send{Int}\Recv{Int}\End} &,\;
y : \type{\Recv{Int}\Send{Int}\End}
\reduce
\\
x : \type{\Recv{Int}\End} &,\;
y : \type{\Send{Int}\End}
\reduce
\\
x : \type{\End} &,\;
y : \type{\End}
\end{align*}

\subsection{Typing rules}

Session-typed channels restrict the syntax of the \picalc{}:

\begin{mathpar}
\inferrule
    {\Gamma \types x : \End}
    {\Gamma \types \PO}
    \quad (\textsc{T-Inact})

\inferrule
    {\Gamma_1 \types P \\
     \Gamma_2 \types Q}
    {\Gamma_1 \circ \Gamma_2 \types \comp{P}{Q}}
    \quad (\textsc{T-Par})

\inferrule
    {\Gamma,x:T,y:\dual{T} \types P}
    {\Gamma \types \new{x}{y}P}
    \quad (\textsc{T-Res})

\inferrule
    {\Gamma_1 \types x:\Recv{T}S \\
     \Gamma_2,x:S,y:T \types P}
    {\Gamma_1 \circ \Gamma_2 \types \cin{x}{y}P}
    \quad (\textsc{T-In})

\inferrule
    {\Gamma_1 \types x:\Send{T}S \\
     \Gamma_2 \types v:T \\
     \Gamma_3,x:S \types P}
    {\Gamma_1 \circ \Gamma_2 \circ \Gamma_3 \types \cout{x}{v}P}
    \quad (\textsc{T-Out})

\inferrule
    {\Gamma_1 \types x:\Branch{\{l_i : S_i\}_{i \in I}} \\
     \Gamma_2,x:S_i \types P_i \\
     \forall i \in I}
    {\Gamma_1 \circ \Gamma_2 \types x \branch{\{l_i : P_i\}_{i \in I}}}
    \quad (\textsc{T-Branch})

\inferrule
    {\Gamma_1 \types x:\Select{\{l_i : S_i\}_{i \in I}} \\
     \Gamma_2,x:S_i \types P_i \\
     \exists j \in I}
    {\Gamma_1 \circ \Gamma_2 \types x \select{l_j}P}
    \quad (\textsc{T-Select})
\end{mathpar}

\subsection{Duality}

It is worth noting that in the introduced example the session types of $x$ and $y$ must be \emph{dual}: when one channel sends a type \type{T}, the other must receive \type{T}, and then both must continue dually. Duality and linearity (a session type must transition through each of its stages exactly once) are the basis for the properties that session types guarantee.

\begin{mathpar}
\inferrule{}{\dual{\Send{T}S} = \Recv{T}\dual{S}}

\inferrule{}{\dual{\Recv{T}S} = \Send{T}\dual{S}}

\inferrule{}{
    \dual{\Branch \{l_i : S_i\}_{i \in I}} =
    \Select \{l_i : \dual{S_i}\}_{i \in I}}

\inferrule{}{
    \dual{\Select\{l_i : S_i\}_{i \in I}} =
    \Branch \{l_i : \dual{S_i}\}_{i \in I}}

\inferrule{}{\dual{\End} = \End}
\end{mathpar}

\subsection{Reduction}

\subsection{Properties}\label{session-types-properties}

Session types guarantee:

\begin{description}
    \item [communication privacy] at any given moment exactly two processes communicate over a channel;
        
    \item [session fidelity] processes follow session types sequentially; and 
        
    \item [communication safety] processes only send what their counterpart is expecting to receive.
\end{description}
        
\todo{linearity ensures communication privacy}
\todo{duality ensures communication safety}
\todo{subject reduction ensures all three}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Coq proof assistant}\label{coq}

Coq \cite{CoqDeveloperCommunity} is a popular proof assistant and dependently typed functional language based on the calculus of inductive constructions \cite{Coquand1989} (which adds inductive data types to the calculus of constructions \cite{Coquand1985}), a type theory isomorphic to intuitionistic predicate calculus --- a constructive logic with quantified statements.

Since types may contain arbitrary definitions, definitions in Coq must exhibit termination --- recursion must occur on structurally smaller terms. Coq supports inductive and coinductive data types, and features proof irrelevance for proofs (in \type{Prop}) and a cumulative set of universes (in \type{Type}).

Coq allows users to build proofs using \emph{tactics}: programs written in $L_{tac}$ that manipulate hypotheses and transform goals. While these programs might be incorrect, or not terminate, their outcome is ultimately checked by \emph{Gallina}, the specification language of Coq.

In Coq, simultaneously pattern matching on multiple indexed data types can be rather clunky and arduous. The \emph{Equations} package eases this inconvenience by adding equational definitions, pattern matching on the left, and \texttt{with} constructs (\cite{McBride2004}), making Coq as convenient for dependent pattern matching as Agda.

\todo{explain example}
\begin{coq}
Inductive Even : nat -> Prop :=
| zero : Even 0
| oddsuc : forall {n : nat}, Odd n -> Even (S n)
with Odd : nat -> Prop :=
| evensuc : forall {n : nat}, Even n -> Odd (S n)
.

Theorem decide_evenness0 (n : nat) : Even n + Odd n.
Proof.
  induction n.
  left; constructor.
  destruct IHn; [right | left]; constructor; assumption.
Qed.

From Equations Require Import Equations.
Equations decide_evenness1 (n : nat) : Even n + Odd n := {
decide_evenness1 0 := inl zero ;
decide_evenness1 (S n) with decide_evenness1 n := {
decide_evenness1 (S n) (inl p) := inr (evensuc p);
decide_evenness1 (S n) (inr p) := inl (oddsuc p)}}.
\end{coq}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Polymorphism}\label{polymorphism}

\cite{Wadler1989}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Dependent types}\label{dependent-types}

Types that depend on programs
\todo{Indexed datatypes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Design}\label{design}

\todo{Limit ourselves to channels with session types, no \#T}
\todo{Limit ourselves to linear types: $\circ$ is union of non intersecting sets}

This chapter covers the high-level design of the encoding of the session-typed \picalc{} into Coq. \todo{The main goal is using function abstraction}

Other efforts in formalising session types in Coq have created object languages and handled variable references, typing contexts, and typing judgments by hand \cite{Dilmore2019}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview}\label{overview}



Central to computing session-typed \picalc is the need to handle the state transitions of session types. One approach is \emph{continuation passing}, introduced in \S \ref{continuation-passing}, which destroys channels and creates new ones as part of every action of a process \cite{Dardha2016}. While there exist other approaches \todo{citation needed}, they all require for every state a session type is in to be used exactly once, i.e. linearity, discussed in \S \ref{linearity}.

\todo{mention the prize to pay}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Continuation passing}\label{continuation-passing}

\cite{Vasconcelos2010}
\todo{We merge pi calculus and session types into one}


Assuming linearity, \textbf{processes are correct by construction}: the processes that can be constructed depend on the session types of the channels in the environment of the host language; an action strips off the outer layer of a channel's session type -- modelling \textbf{continuation passing}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Linearity}\label{linearity}

\cite{Kobayashi1999}
\cite{Toninho2011}

One approach to simulating linearity is traversing processes \emph{a posteriori}, after they have been defined, to check that each channel is used exactly once. This can be done by making the type of channels parametric, and then instantiating it to $\mathbb{B}$ and \emph{marking} each channel for inspection. This allows both channel creation and message input to be modelled as function abstraction --- channels of a parametric type cannot be forged.  However, to be able to traverse processes where message passing is modelled as function abstraction, one has to be able to create all types of messages. To elude this problem, message types can be parametrised over a $\mathrm{Type} \rightarrow \mathrm{Type}$ function and then projected to the unit type.
    
Unfortunately, the approach in point (i) makes it impossible for processes to use any logic that is external to the calculus and depends on the type of messages. An alternative approach for simulating linearity is by doing it \emph{a priori}, at construction time, by keeping track of the linearly available channels through a context by which processes are indexed.  This means that channel creation cannot be represented through function abstraction, that process composition needs to explicitly split the context, and that there must be a way of addressing a particular channel within a context --- strings with the Barendregt convention \cite{Barendregt1984}, De Bruijn indices \cite{deBruijn1972}, locally nameless De Bruijn indices, or a parametric HOAS \cite{Chlipala2008} --- since only channels need to be used linearly, message input can still be represented as function abstraction whenever the message does not contain a channel. On the bright side, this approach allows processes to use logic that external to the calculus and depends on the types of messages.

While the latter approach has more appealing properties, its mechanics negatively affect usability: can it be equipped with the usability of the former approach? I intend to create a Coq library that abstracts away the simulation of linearity.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Parametric HOAS}\label{phoas}

\cite{Wadler1989}
\cite{Chlipala2008}
\todo{We use polymorphism to make channels opaque}
\todo{We do not do open processes}
\todo{We use polymorphism on messages to make processes traversable}

The introduction of both channels and received messages is modelled as function abstraction in Coq, therefore \textbf{variables are handled transparently} -- no substitution related lemmas are required. Channel types are parametrised to make them opaque -- they cannot be illicitly created or inspected by the user.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Subject reduction}\label{subject-reduction}

Ensuring that linearity is preserved through reduction is therefore essential:
\begin{theorem}
    $lin(P) \Rightarrow P \rightarrow Q \Rightarrow lin(Q).$
\end{theorem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation}\label{implementation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Session types}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Messages and processes}\label{processes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Linearity check}\label{linearity-check}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Linearity preservation}\label{linearity-preservation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Examples}\label{examples}

\todo{Type inference}
\begin{coq}
Example example1 : PProcess.
  refine
  ([v]> (new i <- _, o <- _, _)
    (i?[m]; ![m]; $\epsilon$) <|> (o![v _ true]; ?[m]; $\epsilon$)).
  auto.
Defined.
Print example1.

Example example2 : PProcess :=
  ([v]> (new o <- ! B[bool] ; ? B[bool] ; ø, i <- ? B[bool] ; ! B[bool] ; ø, ltac:(auto))
    (o![v _ true]; ?[m]; $\epsilon$) <|> i?[m]; ![m]; $\epsilon$).

Example congruent_example1 : example1 $\equiv$ example2. auto. Qed.

Example example3 : PProcess :=
  ([v]> (new o <- ? B[bool] ; ø, i <- ! B[bool] ; ø, ltac:(auto))
    (o?[m]; $\epsilon$) <|> i![v _ true]; $\epsilon$).

Example reduction_example1 : example2 => example3. auto. Qed.

Example subject_reduction_example1 : example2 => example3 -> Linear example2 -> Linear example3.
eauto.
Qed.

Example example4 : PProcess :=
  ([v]> (new i <- ! B[bool] ; ø, o <- ? B[bool] ; ø, ltac:(auto))
    (i![v _ true]; $\epsilon$ <|> o?[m]; $\epsilon$)).

Example congruent_example2 : example3 $\equiv$ example4. auto. Qed.

Example example5 : PProcess :=
  ([v]> (new i <- ø, o <- ø, Ends) ($\epsilon$ i <|> $\epsilon$ o)).

Example reduction_example2 : example4 => example5. auto. Qed.

Example big_step_reduction : example1 =>* example5. auto. Qed.

Example big_step_subject_reduction_example1
  : example1 =>* example5 -> Linear example1 -> Linear example5.
eauto.
Qed.

Example channel_over_channel : PProcess :=
  [v]>
    (new i <- ? C[ ! B[bool] ; ø ] ; ø, o <- ! C[ ! B[bool] ; ø ] ; ø, MLeft Ends)
    (new i' <- ? B[bool] ; ø, o' <- _, MLeft Ends)

    (i?[c]; fun a => $\epsilon$ a <|> c![v _ true]; $\epsilon$)
    <|>
    (o![o']; fun a => $\epsilon$ a <|> i'?[_]; $\epsilon$)
.

Example channel_over_channel1 : PProcess :=
  [v]>
    (new i' <- ? B[bool] ; ø, o' <- ! B[bool] ; ø, MLeft Ends)
    (new i <- ? C[ ! B[bool] ; ø ] ; ø, o <- ! C[ ! B[bool] ; ø ] ; ø, MLeft Ends)

    (i?[c]; fun a => c![v _ true]; $\epsilon$ <|> $\epsilon$ a)
    <|>
    (o![o']; fun a => i'?[_]; $\epsilon$ <|> $\epsilon$ a)
.

Example congruent_example3 : channel_over_channel $\equiv$ channel_over_channel1. auto. Qed.

Example nonlinear_example : PProcess :=
  [v]> (new i <- ? B[bool] ; ø, o <- ! B[bool] ; ø, MLeft Ends)

    (* Cheat the system by using the channel o twice *)
    i?[_]; $\epsilon$ <|> o![v _ true]; (fun _ => o![v _ true]; $\epsilon$)
    .

Example linear_example1 : Linear example1. auto. Qed.

Example linear_channel_over_channel : Linear channel_over_channel. auto. Qed.

Example nonlinear_example1 : ~ (Linear nonlinear_example). auto. Qed.

Example branch_and_select : PProcess :=
  ([v]> (new
           i <- &{ (! B[bool] ; ø) :: (? B[bool] ; ø) :: [] },
           o <- $\oplus${ (? B[bool] ; ø) :: (! B[bool] ; ø) :: [] },
           ltac:(auto))
          i$\triangleright${(![v _ true]; $\epsilon$) ; (?[m]; $\epsilon$)} <|> o$\triangleleft$Fin.F1; ?[_]; $\epsilon$).
\end{coq}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Related work}\label{related-work}

Linearity is strongly connected to session types: a session type must transition through each of its stages \emph{exactly} once. Session types can be encoded into a \picalc{} with linear types, as shown by \cite{Kobayashi1996,Dardha2012,Dardha2016}. As shown in \cite{Voinea}, in systems where session types are shared, the tokens allowing access to the session-typed channels must still be linear.

The connection between session types and linearity can be drawn even further, at the logical level, where an isomorphism between linear logic and session types can be shown \cite{Caires2010} \cite{Wadler2014}. In \cite{Lindley2015} the operational semantics for a session-typed functional language that builds on Wadler's isomorphism are given. This work is continued in \cite{Lindley}, where the language is extended with polymorphism, row types, subkinding, and non-linear data types. \cite{Gay2010} uses a linear type-system to encode asynchronous session types with buffers --- and then verify properties of those buffers.

In type systems with no linear types the linearity of channels has to be simulated. In these type systems, modelling channels through a parametric higher order abstract syntax \cite{Chlipala2008} is not possible per se: the host language is unable to check whether the channels passed along as arguments are used linearly. This means that typing judgments must happen at the object language, through the use of a context that keeps track of linear resources.  This context is usually tracked at the type level, using inductive \emph{families} \cite{Dybjer1994} indexed by a context of linear resources \cite{Power2000} --- though there are approaches that keep track of context through type-classes and use monadic binding to embed a linear calculus within non-linear hosts \cite{Paykin2017}.

The \picalc{} has been an extensive subject of machine verification: \cite{Henry-Gerard1999} proofs subject reduction for it; \cite{Despeyroux2000} proofs subject reduction as well, but uses a higher order syntax; \cite{Affeldt2008} provides proofs of fairness and confluence; \cite{Honsell2001} formalises the bisimilarity proofs found in \cite{Walker1989}; \cite{Gay2001} provides a framework for formalisation on the \picalc{} with linear channels in Isabelle/HOL.

In \cite{Xi2016} session types are formalised in ATS, providing type preservation and global progress proofs. \cite{Bock2016} uses Celf to represent session types in intuitionistic linear logic.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}\label{conclusion}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{alpha}
\bibliography{mproj}
\end{document}
