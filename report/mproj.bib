
@article{Affeldt2008,
  abstract = {Thanks to recent advances, modern proof assistants now enable verification of realistic sequential programs. However, regarding the concurrency paradigm, previous work essentially focused on formalization of abstract systems, such as pure concurrent calculi, which are too minimal to be realistic. In this paper, we propose a library that enables verification of realistic concurrent programs in the Coq proof assistant. Our approach is based on an extension of the {$\pi$}-calculus whose encoding enables such programs to be modeled conveniently. This encoding is coupled with a specification language akin to spatial logics, including in particular a notion of fairness, which is important to write satisfactory specifications for realistic concurrent programs. In order to facilitate formal proof, we propose a collection of lemmas that can be reused in the context of different verifications. Among these lemmas, the most effective for simplifying the proof task take advantage of confluence properties. In order to evaluate feasibility of verification of concurrent programs using this library, we perform verification for a non-trivial application.},
  author = {Affeldt, Reynald and Kobayashi, Naoki},
  doi = {10.1016/j.entcs.2007.11.010},
  file = {/home/uma/references/papers/Affeldt_Kobayashi_2008_A Coq Library for Verification of Concurrent Programs.pdf;/home/uma/.zotero/data/storage/EL75KDDA/S1571066108000765.html},
  issn = {1571-0661},
  journal = {Electronic Notes in Theoretical Computer Science},
  keywords = {concurrent programs,Coq,pi-calculus,Proof assistant},
  month = feb,
  pages = {17-32},
  series = {Proceedings of the {{Fourth International Workshop}} on {{Logical Frameworks}} and {{Meta}}-{{Languages}} ({{LFM}} 2004)},
  title = {A {{Coq Library}} for {{Verification}} of {{Concurrent Programs}}},
  volume = {199},
  year = {2008}
}

@book{Barendregt1984,
  address = {{Amsterdam ; New York : New York, N.Y}},
  author = {Barendregt, H. P.},
  edition = {Rev. ed},
  isbn = {978-0-444-86748-3 978-0-444-87508-2},
  keywords = {Lambda calculus},
  lccn = {QA9.5 .B36 1984},
  number = {v. 103},
  publisher = {{North-Holland ; Sole distributors for the U.S.A. and Canada, Elsevier Science Pub. Co}},
  series = {Studies in Logic and the Foundations of Mathematics},
  shorttitle = {The Lambda Calculus},
  title = {The Lambda Calculus: Its Syntax and Semantics},
  year = {1984}
}

@article{Bock2016,
  author = {Bock, Peter Brottveit and Bruni, Alessandro and Murawska, Agata and Sch{\"u}rmann, Carsten},
  journal = {Dale Miller's Festschrift},
  title = {Representing {{Session Types}}},
  year = {2016}
}

@article{Chargueraud2012,
  abstract = {This paper provides an introduction to the locally nameless approach to the representation of syntax with variable binding, focusing in particular on the use of this technique in formal proofs. First, we explain the benefits of representing bound variables with de Bruijn indices while retaining names for free variables. Then, we explain how to describe and manipulate syntax in that form, and show how to define and reason about judgments on locally nameless terms.},
  author = {Chargu{\'e}raud, Arthur},
  doi = {10.1007/s10817-011-9225-2},
  file = {/home/uma/.zotero/data/storage/6RT2UBX4/Charguéraud - 2012 - The Locally Nameless Representation.pdf},
  issn = {0168-7433, 1573-0670},
  journal = {Journal of Automated Reasoning},
  keywords = {check},
  language = {en},
  month = oct,
  number = {3},
  pages = {363-408},
  title = {The {{Locally Nameless Representation}}},
  volume = {49},
  year = {2012}
}

@inproceedings{Chlipala2008,
  author = {Chlipala, Adam},
  booktitle = {{{ACM SIGPLAN Notices}}},
  doi = {10.1145/1411204.1411226},
  file = {/home/uma/references/papers/Chlipala_2008_Parametric Higher-Order Abstract Syntax for Mechanized Semantics.pdf},
  month = sep,
  pages = {143-156},
  title = {Parametric {{Higher}}-{{Order Abstract Syntax}} for {{Mechanized Semantics}}},
  volume = {43},
  year = {2008}
}

@misc{CoqDeveloperCommunity,
  author = {{Coq Developer Community}},
  howpublished = {https://coq.inria.fr/},
  journal = {The Coq Proof Assistant},
  title = {The {{Coq Proof Assistant}}}
}

@article{Coquand1985,
  author = {Coquand, Thierry and Huet, G{\'e}rard},
  doi = {https://doi.org/10.1016/0890-5401(88)90005-3},
  file = {/home/uma/references/papers/Coquand_Huet_1985_The Calculus of Constructions.pdf},
  issn = {0890-5401},
  journal = {Information and Computation},
  number = {2},
  pages = {95-120},
  title = {The {{Calculus}} of {{Constructions}}},
  volume = {76},
  year = {1985}
}

@inproceedings{Coquand1990,
  author = {Coquand, Thierry and Paulin, Christine},
  booktitle = {{{COLOG}}-88},
  editor = {{Martin-L{\"o}f}, Per and Mints, Grigori},
  isbn = {978-3-540-46963-6},
  keywords = {Computation Rule,Elimination Rule,Inductive Type,Positive Operator,Type Theory},
  language = {en},
  pages = {50-66},
  publisher = {{Springer Berlin Heidelberg}},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Inductively Defined Types},
  year = {1990}
}

@inproceedings{Dardha2012,
  author = {Dardha, Ornela and Giachino, Elena and Sangiorgi, Davide},
  booktitle = {Principles and {{Practice}} of {{Declarative Programming}}, {{PPDP}}'12, {{Leuven}}, {{Belgium}} - {{September}} 19 - 21, 2012},
  doi = {10.1145/2370776.2370794},
  editor = {Schreye, Danny De and Janssens, Gerda and King, Andy},
  file = {/home/uma/references/papers/Dardha et al_2012_Session types revisited.pdf},
  isbn = {978-1-4503-1522-7},
  pages = {139--150},
  publisher = {{ACM}},
  title = {Session Types Revisited},
  year = {2012}
}

@incollection{Dardha2016,
  abstract = {In this chapter we introduce the encoding of session types into linear channel types and variant types and of session processes into standard \$\$\textbackslash{}pi \$\${$\pi$}-calculus processes.},
  author = {Dardha, Ornela},
  booktitle = {Type {{Systems}} for {{Distributed Programs}}: {{Components}} and {{Sessions}}},
  doi = {10.2991/978-94-6239-204-5_6},
  file = {/home/uma/references/papers/Dardha_2016_Session Types Revisited.pdf},
  isbn = {978-94-6239-203-8},
  month = jan,
  publisher = {{Springer}},
  title = {Session {{Types Revisited}}},
  year = {2016}
}

@article{Dardha2017,
  author = {Dardha, Ornela and Giachino, Elena and Sangiorgi, Davide},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  biburl = {https://dblp.org/rec/bib/journals/iandc/DardhaGS17},
  doi = {10.1016/j.ic.2017.06.002},
  journal = {Inf. Comput.},
  pages = {253-286},
  timestamp = {Fri, 30 Nov 2018 13:26:00 +0100},
  title = {Session Types Revisited},
  volume = {256},
  year = {2017}
}

@inproceedings{deBruijn1972,
  author = {{de Bruijn}, Nicolaas Govert},
  booktitle = {Indagationes {{Mathematicae}} ({{Proceedings}})},
  pages = {381-392},
  publisher = {{Elsevier}},
  title = {Lambda {{Calculus Notation}} with {{Nameless Dummies}}, a {{Tool}} for {{Automatic Formula Manipulation}}, with {{Application}} to the {{Church}}-{{Rosser Theorem}}},
  volume = {75},
  year = {1972}
}

@book{Despeyroux2000,
  abstract = {We present a formalization of a typed pi-calculus in the Calculus of Inductive Constructions. We give the rules for type-checking and for evaluation and formalize a proof of type preservation in the Coq system. The encoding of the pi-calculus in Coq uses Coq fonctions to represent bindings of variables. This kind of encoding is called a higher-order specication. It provides a concise description of the calculus, leading to simple proofs. The specification we propose for the pi-calculus formalizes communication by means of function application.},
  author = {Despeyroux, Jo{\"e}lle},
  file = {/home/uma/references/papers/Despeyroux_2000_A Higher-Order Specification of the π-Calculus.pdf;/home/uma/.zotero/data/storage/P2ZN3T47/summary.html},
  title = {A {{Higher}}-{{Order Specification}} of the {$\pi$}-{{Calculus}}},
  year = {2000}
}

@inproceedings{Dezani-ciancaglini2010,
  author = {{Dezani-ciancaglini}, Mariangiola and De'Liguoro, Ugo},
  doi = {10.1007/978-3-642-14458-5_1},
  file = {/home/uma/references/papers/Dezani-ciancaglini_De'Liguoro_2010_Sessions and Session Types.pdf;/home/uma/references/papers/Dezani-ciancaglini_De'Liguoro_2010_Sessions and Session Types2.pdf},
  month = aug,
  pages = {1-28},
  title = {Sessions and {{Session Types}}: {{An Overview}}},
  year = {2010}
}

@phdthesis{Dilmore2019,
  author = {Dilmore, Eric},
  school = {School of Computing Science, University of Glasgow},
  title = {Pi-{{Calculus Session Types}} in {{Coq}}},
  type = {Master's {{Thesis}}},
  year = {2019}
}

@article{Dreyer2018,
  acmid = {3158154},
  articleno = {66},
  author = {Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
  doi = {10.1145/3158154},
  file = {/home/uma/references/papers/Jung et al_2017_RustBelt.pdf},
  issn = {2475-1421},
  issue_date = {January 2018},
  journal = {Proc. ACM Program. Lang.},
  keywords = {concurrency,logical relations,Rust,separation logic,type systems},
  location = {New York, NY, USA},
  month = dec,
  number = {POPL},
  numpages = {34},
  pages = {66:1-66:34},
  publisher = {{ACM}},
  title = {{{RustBelt}}: {{Securing}} the {{Foundations}} of the {{Rust Programming Language}}},
  volume = {2},
  year = {2017}
}

@article{Dybjer1994,
  abstract = {A general formulation of inductive and recursive definitions in Martin-L{\"o}f's type theory is presented. It extends Backhouse's `Do-It-Yourself Type Theory' to include inductive definitions of families of sets and definitions of functions by recursion on the way elements of such sets are generated. The formulation is in natural deduction and is intended to be a natural generalisation to type theory of Martin-L{\"o}f's theory of iterated inductive definitions in predicate logic.
Formal criteria are given for correct formation and introduction rules of a new set former capturing definition by strictly positive, iterated, generalised induction. Moreover, there is an inversion principle for deriving elimination and equality rules from the formation and introduction rules. Finally, there is an alternative schematic presentation of definition by recursion.
The resulting theory is a flexible and powerful language for programming and constructive mathematics. We hint at the wealth of possible applications by showing several basic examples: predicate logic, generalised induction, and a formalisation of the untyped lambda calculus.},
  author = {Dybjer, Peter},
  doi = {10.1007/BF01211308},
  file = {/home/uma/references/papers/Dybjer_1994_Inductive families.pdf},
  journal = {Formal Aspects of Computing},
  month = jan,
  pages = {440-465},
  title = {Inductive Families},
  volume = {6},
  year = {1994}
}

@incollection{Felty2010,
  abstract = {A variety of logical frameworks support the use of higherorder abstract syntax (HOAS) in representing formal systems given via axioms and inference rules and reasoning about them. In such frameworks, object-level binding is encoded directly using meta-level binding. Although these systems seem superficially the same, they differ in a variety of ways; for example, in how they handle a context of assumptions and in what theorems about a given formal system can be expressed and proven. In this paper, we present several case studies which highlight a variety of different aspects of reasoning using HOAS, with the intention of providing a basis for comparison of different systems. We then carry out such a comparison among three systems: Twelf, Beluga, and Hybrid. We also develop a general set of criteria for comparing such systems. We hope that others will implement these challenge problems, apply these criteria, and further our understanding of the trade-offs involved in choosing one system over another for this kind of reasoning.},
  address = {{Berlin, Heidelberg}},
  author = {Felty, Amy and Pientka, Brigitte},
  booktitle = {Interactive {{Theorem Proving}}},
  doi = {10.1007/978-3-642-14052-5_17},
  editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Doug and Vardi, Moshe Y. and Weikum, Gerhard and Kaufmann, Matt and Paulson, Lawrence C.},
  file = {/home/uma/.zotero/data/storage/38E735IG/Felty and Pientka - 2010 - Reasoning with Higher-Order Abstract Syntax and Co.pdf},
  isbn = {978-3-642-14051-8 978-3-642-14052-5},
  language = {en},
  pages = {227-242},
  publisher = {{Springer Berlin Heidelberg}},
  shorttitle = {Reasoning with {{Higher}}-{{Order Abstract Syntax}} and {{Contexts}}},
  title = {Reasoning with {{Higher}}-{{Order Abstract Syntax}} and {{Contexts}}: {{A Comparison}}},
  volume = {6172},
  year = {2010}
}

@inproceedings{Gay2001,
  abstract = {We present a formalisation, in the theorem proving system Isabelle/HOL, of a linear type system for the pi calculus, including a proof of runtime safety of typed processes. The use of a uniform encoding of pi calculus syntax in a meta language, the development of a general theory of type environments, and the structured formalisation of the main proofs, facilitate the adaptation of the Isabelle theories and proof scripts to variations on the language and other type systems.},
  author = {Gay, Simon J.},
  booktitle = {Theorem {{Proving}} in {{Higher Order Logics}}},
  editor = {Boulton, Richard J. and Jackson, Paul B.},
  file = {/home/uma/references/papers/Gay_2001_A Framework for the Formalisation of Pi Calculus Type Systems in Isabelle-HOL.pdf},
  isbn = {978-3-540-44755-9},
  keywords = {automatic theorem proving,pi calculus,semantics,Types},
  language = {en},
  pages = {217-232},
  publisher = {{Springer Berlin Heidelberg}},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {A {{Framework}} for the {{Formalisation}} of {{Pi Calculus Type Systems}} in {{Isabelle}}/{{HOL}}},
  year = {2001}
}

@inproceedings{Giunti2010,
  abstract = {We present a reconstruction of session types in a conventional pi calculus where types are qualified as linear or unrestricted. Linearly typed communication channels are guaranteed to occur in exactly one thread, possibly multiple times. We equip types with a constructor that denotes the two ends of a same communication channel. In order to assess the flexibility of the new type system, we provide three distinct encodings (from the linear lambda calculus, from the linear pi calculus, and from the pi calculus with polarized variables) into our system. For each language we present operational and typing correspondences, showing that our system effectively subsumes the linear pi calculus as well as foregoing works on session types.},
  author = {Giunti, Marco and Vasconcelos, Vasco T.},
  booktitle = {{{CONCUR}} 2010 - {{Concurrency Theory}}},
  editor = {Gastin, Paul and Laroussinie, Fran{\c c}ois},
  isbn = {978-3-642-15375-4},
  pages = {432-446},
  publisher = {{Springer Berlin Heidelberg}},
  title = {A {{Linear Account}} of {{Session Types}} in the {{Pi Calculus}}},
  year = {2010}
}

@article{Goto2016,
  abstract = {Session types describe and constrain the input/output behaviour of systems. Existing session typing systems have limited support for polymorphism. For example, existing systems cannot provide the most general type for a generic proxy process that forwards messages between two channels. We provide a polymorphic session typing system for the {$\pi$} calculus, and demonstrate the utility of session-type-level functions in combination with polymorphic session typing. The type system guarantees subject reduction and safety properties, but not deadlock freedom. We describe a formalization of the type system in Coq. The proofs of subject reduction and safety properties, as well as typing of example processes, have been mechanically verified.},
  author = {Goto, Matthew and Jagadeesan, Radha and Jeffrey, Alan and Pitcher, Corin and Riely, James},
  doi = {10.1017/S0960129514000231},
  file = {/home/uma/.zotero/data/storage/E6TZEIHF/Goto et al. - 2016 - An extensible approach to session polymorphism.pdf},
  issn = {0960-1295, 1469-8072},
  journal = {Mathematical Structures in Computer Science},
  language = {en},
  month = mar,
  number = {3},
  pages = {465-509},
  title = {An Extensible Approach to Session Polymorphism},
  volume = {26},
  year = {2016}
}

@book{Henry-Gerard1999,
  abstract = {This paper presents a method for coding pi-calculus in the COQ proof assistant, in order to use this environment to formalize properties of the pi-calculus. This method consists in making a syntactic discrimination between free names (then called parameters) and bound names (then called variables) of the processes, so that implicit renamings of bound names are avoided in the substitution operation. This technique has been used by J.McKinna and R.Pollack in an extensive study of PTS [5]. We use this coding here to prove subject reduction property for a type system of a monadic pi-calculus.},
  author = {{Henry-G{\'e}rard}, Lo{\"i}c and Meije, Projet},
  file = {/home/uma/references/papers/Henry-Gérard_Meije_1999_Proof of the subject reduction property for a π-calculus in COQ.pdf;/home/uma/.zotero/data/storage/FVFRE453/summary.html},
  title = {Proof of the Subject Reduction Property for a {$\pi$}-Calculus in {{COQ}}},
  year = {1999}
}

@inproceedings{Honda1993,
  abstract = {We formulate a typed formalism for concurrency where types denote freely composable structure of dyadic interaction in the symmetric scheme. The resulting calculus is a typed reconstruction of name passing process calculi. Systems with both the explicit and implicit typing disciplines, where types form a simple hierarchy of types, are presented, which are proved to be in accordance with each other. A typed variant of bisimilarity is formulated and it is shown that typed {$\beta$}-equality has a clean embedding in the bisimilarity. Name reference structure induced by the simple hierarchy of types is studied, which fully characterises the typable terms in the set of untyped terms. It turns out that the name reference structure results in the deadlock-free property for a subset of terms with a certain regular structure, showing behavioural significance of the simple type discipline.},
  author = {Honda, Kohei},
  booktitle = {{{CONCUR}}'93},
  editor = {Best, Eike},
  isbn = {978-3-540-47968-0},
  keywords = {Atomic Type,Constant Symbol,Dyadic Interaction,Functional Type,Reference Structure},
  language = {en},
  pages = {509-523},
  publisher = {{Springer Berlin Heidelberg}},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Types for Dyadic Interaction},
  year = {1993}
}

@incollection{Honda1998,
  abstract = {We introduce basic language constructs and a type discipline as a foundation of structured communication-based concurrent programming. The constructs, which are easily translatable into the summation-less asynchronous {$\pi$}-calculus, allow programmers to organise programs as a combination of multiple flows of (possibly unbounded) reciprocal interactions in a simple and elegant way, subsuming the preceding communication primitives such as method invocation and rendez-vous. The resulting syntactic structure is exploited by a type discipline `a la ML, which offers a high-level type abstraction of interactive behaviours of programs as well as guaranteeing the compatibility of interaction patterns between processes in a well-typed program. After presenting the formal semantics, the use of language constructs is illustrated through examples, and the basic syntactic results of the type discipline are established. Implementation concerns are also addressed.},
  address = {{Berlin, Heidelberg}},
  author = {Honda, Kohei and Vasconcelos, Vasco T. and Kubo, Makoto},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  doi = {10.1007/BFb0053567},
  editor = {Goos, Gerhard and Hartmanis, Juris and {van Leeuwen}, Jan and Hankin, Chris},
  file = {/home/uma/.zotero/data/storage/FSEHSQGD/Honda et al. - 1998 - Language primitives and type discipline for struct.pdf},
  isbn = {978-3-540-64302-9 978-3-540-69722-0},
  language = {en},
  pages = {122-138},
  publisher = {{Springer Berlin Heidelberg}},
  title = {Language Primitives and Type Discipline for Structured Communication-Based Programming},
  volume = {1381},
  year = {1998}
}

@article{Honsell2001,
  abstract = {We present a large and we think also significant case study in computer assisted formal reasoning. We start by giving a higher-order abstract syntax encoding of {$\pi$}-calculus in the higher-order inductive/coinductive-type theories CIC and CC(Co)Ind. This encoding gives rise to a full-fledged proof editor/proof assistant for the {$\pi$}-calculus, once we embed it in Coq, an interactive proof-development environment for CC(Co)Ind. Using this computerized assistant we prove formally a substantial chapter of the theory of strong late bisimilarity, which amounts essentially to Section 2 of A calculus of mobile processes by Milner, Parrow, and Walker. This task is greatly simplified by the use of higher-order syntax. In fact, not only we can delegate conveniently to the metalanguage {$\alpha$}-conversion and substitution, but, introducing a suitable axiomatization of the theory of contexts, we can accommodate also the machinery for generating new names. The axiomatization we introduce is quite general and should be easily portable to other formalizations based on higher-order syntax. The use of coinductive types and corresponding tactics allows to give alternative, and possibly more natural, proofs of many properties of strong late bisimilarity, w.r.t. those originally given by Milner, Parrow, and Walker.},
  author = {Honsell, Furio and Miculan, Marino and Scagnetto, Ivan},
  doi = {10.1016/S0304-3975(00)00095-5},
  file = {/home/uma/references/papers/Honsell et al_2001_π-calculus in (Co)inductive-type theory.pdf;/home/uma/.zotero/data/storage/KLRGFM2S/S0304397500000955.html},
  issn = {0304-3975},
  journal = {Theoretical Computer Science},
  keywords = {-calculus,Higher-order abstract syntax,Logical frameworks,Proof checking,Typed -calculus},
  month = feb,
  number = {2},
  pages = {239-285},
  series = {{{IC}}-{{EATCS}}'97},
  title = {{$\pi$}-Calculus in ({{Co}})Inductive-Type Theory},
  volume = {253},
  year = {2001}
}

@book{Kobayashi1996,
  abstract = {The economy and flexibility of the pi-calculus make it attractive both as an object of theoretical study and as a basis for concurrent language design and implementation. However, such generality has a cost: encoding higher-level features like functional computation in pi-calculus throws away potentially useful information. We show how a linear type system can be used to recover important static information about a process's behaviour. In particular, we can guarantee that two processes communicating over a linear channel cannot interfere with other communicating processes. This enables more aggressive optimisation of communications over linear channels and allows useful refinements to the usual notions of process equivalence for pi-calculus. After},
  author = {Kobayashi, Naoki and Pierce, Benjamin C. and Turner, David N.},
  file = {/home/uma/references/papers/Kobayashi et al_1996_Linearity and the Pi-Calculus.pdf;/home/uma/.zotero/data/storage/7QEAP97G/summary.html},
  title = {Linearity and the {{Pi}}-{{Calculus}}},
  year = {1996}
}

@article{Kobayashi1999,
  author = {Kobayashi, Naoki and Pierce, Benjamin and N. Turner, David},
  doi = {10.1145/330249.330251},
  file = {/home/uma/references/papers/Kobayashi et al_1999_Linearity and the Pi-Calculus.pdf},
  journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
  month = dec,
  pages = {914-947},
  title = {Linearity and the {{Pi}}-{{Calculus}}},
  volume = {21},
  year = {1999}
}

@incollection{Kobayashi2003,
  address = {{Berlin, Heidelberg}},
  author = {Kobayashi, Naoki},
  booktitle = {Formal {{Methods}} at the {{Crossroads}}. {{From Panacea}} to {{Foundational Support}}},
  doi = {10.1007/978-3-540-40007-3_26},
  editor = {Goos, Gerhard and Hartmanis, Juris and {van Leeuwen}, Jan and Aichernig, Bernhard K. and Maibaum, Tom},
  file = {/home/uma/.zotero/data/storage/JX4NCLRW/Kobayashi - 2003 - Type Systems for Concurrent Programs.pdf},
  ids = {Kobayashi2003a},
  isbn = {978-3-540-20527-2 978-3-540-40007-3},
  language = {en},
  pages = {439-453},
  publisher = {{Springer Berlin Heidelberg}},
  title = {Type {{Systems}} for {{Concurrent Programs}}},
  volume = {2757},
  year = {2003}
}

@techreport{Kobayashi2007,
  author = {Kobayashi, Naoki},
  institution = {{Tohoku University}},
  note = {Extended version of Kobayashi 2003},
  title = {Type Systems for Concurrent Programs},
  year = {2007}
}

@article{McBride2004,
  author = {McBride, Conor and McKinna, James},
  journal = {Journal of functional programming},
  number = {1},
  pages = {69-111},
  title = {The {{View}} from the {{Left}}},
  volume = {14},
  year = {2004}
}

@book{Milner1989,
  author = {Milner, R.},
  isbn = {978-0-13-114984-7},
  month = jan,
  publisher = {{Prentice-Hall, Inc.}},
  title = {Communication and {{Concurrency}}},
  year = {1989}
}

@inproceedings{Milner1991,
  author = {Milner, Robin},
  booktitle = {Handbook of Theoretical Computer Science (Vol. {{B}})},
  isbn = {978-0-444-88074-1},
  month = feb,
  pages = {1201-1242},
  publisher = {{MIT Press}},
  title = {Operational and Algebraic Semantics of Concurrent Processes},
  year = {1991}
}

@article{Paykin2017,
  author = {Paykin, Jennifer and Zdancewic, S},
  doi = {10.1145/3156695.3122965},
  file = {/home/uma/references/papers/Paykin_Zdancewic_2017_The Linearity Monad.pdf},
  journal = {ACM SIGPLAN Notices},
  month = sep,
  pages = {117-132},
  title = {The {{Linearity Monad}}},
  volume = {52},
  year = {2017}
}

@article{Petz,
  author = {Petz, Adam},
  file = {/home/uma/.zotero/data/storage/6SG39KD6/Petz - A Semantics for Attestation Protocols using Sessio.pdf},
  language = {en},
  pages = {61},
  title = {A {{Semantics}} for {{Attestation Protocols}} Using {{Session Types}} in {{Coq}}}
}

@article{Power2000,
  author = {Power, James and Webster, Caroline},
  file = {/home/uma/references/papers/Power_Webster_2000_Working with Linear Logic in Coq.pdf},
  month = jul,
  title = {Working with {{Linear Logic}} in {{Coq}}},
  year = {2000}
}

@book{Sangiorgi2001,
  abstract = {From the Publisher:Mobile systems, whose components communicate and change their structure, now pervade the informational world and the wider world of which it is a part. The science of mobile systems is as yet immature, however. This book presents the pi-calculus, a theory of mobile systems. The pi-calculus provides a conceptual framework for understanding mobility, and mathematical tools for expressing systems and reasoning about their behaviors.
The book serves both as a reference for the theory and as an extended demonstration of how to use pi-calculus to describe systems and analyze their properties. It covers the basic theory of pi-calculus, typed pi-calculi, higher-order processes, the relationship between pi-calculus and lambda-calculus, and applications of pi-calculus to object-oriented design and programming.
The book is written at the graduate level, assuming no prior acquaintance with the subject, and is intended for computer scientists interested in mobile systems.},
  address = {{New York, NY, USA}},
  author = {Sangiorgi, Davide and Walker, David},
  isbn = {978-0-521-78177-0},
  publisher = {{Cambridge University Press}},
  shorttitle = {{{PI}}-{{Calculus}}},
  title = {{{PI}}-{{Calculus}}: {{A Theory}} of {{Mobile Processes}}},
  year = {2001}
}

@inproceedings{Takeuchi1994,
  abstract = {We present a small language \$\$\textbackslash{}backslashmathcal\{L\}\$\$and its typing system, starting from the idea of interaction, one of the important notions in parallel and distributed computing. \$\$\textbackslash{}backslashmathcal\{L\}\$\$is based on, apart from such constructs as parallel composition and process creation, three pairs of communication primitives which use the notion of a session, a semantically atomic chain of communication actions which can interleave with other such chains freely, for high-level abstraction of interactionbased computing. The three primitives enable programmers to elegantly describe complex interactions among processes with a rigorous type discipline similar to ML [4]. The language is given formal operational semantics and a type inference system, regarding which we prove that if a program is well-typed in the typing system, it never causes run-time error due to type inconsistent communication patterns, offering a new foundation for type discipline in parallel programming languages.},
  author = {Takeuchi, Kaku and Honda, Kohei and Kubo, Makoto},
  booktitle = {{{PARLE}}'94 {{Parallel Architectures}} and {{Languages Europe}}},
  editor = {Halatsis, Costas and Maritsas, Dimitrios and Philokyprou, George and Theodoridis, Sergios},
  isbn = {978-3-540-48477-6},
  pages = {398-413},
  publisher = {{Springer Berlin Heidelberg}},
  title = {An {{Interaction}}-{{Based Language}} and {{Its Typing System}}},
  year = {1994}
}

@inproceedings{Toninho2011,
  author = {Toninho, Bernardo and Caires, Lu{\'i}s and Pfenning, Frank},
  booktitle = {Proceedings of the 13th {{International ACM SIGPLAN Symposium}} on {{Principles}} and {{Practices}} of {{Declarative Programming}}},
  doi = {10.1145/2003476.2003499},
  isbn = {978-1-4503-0776-5},
  keywords = {process calculus,type theory},
  pages = {161-172},
  publisher = {{ACM}},
  series = {{{PPDP}} '11},
  title = {Dependent {{Session Types}} via {{Intuitionistic Linear Type Theory}}},
  year = {2011}
}

@incollection{Vasconcelos2009,
  author = {Vasconcelos, Vasco},
  booktitle = {Information and {{Computation}}},
  doi = {10.1007/978-3-642-01918-0_4},
  file = {/home/uma/references/papers/Vasconcelos_2009_Fundamentals of Session Types.pdf},
  month = may,
  pages = {158-186},
  title = {Fundamentals of {{Session Types}}},
  volume = {217},
  year = {2009}
}

@article{Voinea,
  abstract = {Multiparty Session Types (MPST) are a type formalism used to model communication protocols among components in distributed systems, by specifying type and direction of data transmitted. It is standard for multiparty session type systems to use access control based on linear or affine types. While useful in offering strong guarantees of communication safety and session fidelity, linearity and affinity run into the well-known problem of inflexible programming, excluding scenarios that make use of shared channels or need to store channels into shared data structures.},
  author = {Voinea, A Laura and Dardha, Ornela and Gay, Simon J},
  file = {/home/uma/references/papers/Voinea et al_Resource Sharing via Capability-Based Multiparty Session Types.pdf},
  language = {en},
  pages = {26},
  title = {Resource {{Sharing}} via {{Capability}}-{{Based Multiparty Session Types}}}
}

@book{Wadler1989,
  abstract = {From the type of a polymorphic function we can derive a theorem that it satisfies. Every function of the same type satisfies the same theorem. This provides a free source of useful theorems, courtesy of Reynolds\&\#039; abstraction theorem for the polymorphic lambda calculus.},
  author = {Wadler, Philip},
  title = {Theorems for {{Free}}!},
  year = {1989}
}

@book{Walker1989,
  author = {Walker, David and Milner, Robin and Parrow, Joachim},
  file = {/home/uma/references/papers/Walker et al_1989_A Calculus of Mobile Processes (Parts I and II).pdf},
  month = jun,
  title = {A {{Calculus}} of {{Mobile Processes}} ({{Parts I}} and {{II}})},
  volume = {100},
  year = {1989}
}

@unpublished{Wing2002,
  author = {Wing, Jeannette M.},
  file = {/home/uma/references/papers/Wing_2002_FAQ on Pi-Calculus.pdf},
  month = dec,
  title = {{{FAQ}} on {{Pi}}-{{Calculus}}},
  year = {2002}
}

@article{Xi2016,
  abstract = {We present a formalization of session types in a multi-threaded lambda-calculus (MTLC) equipped with a linear type system, establishing for the MTLC both type preservation and global progress. The latter (global progress) implies that the evaluation of a well-typed program in the MTLC can never reach a deadlock. As this formulated MTLC can be readily embedded into ATS, a full-fledged language with a functional programming core that supports both dependent types (of DML-style) and linear types, we obtain a direct implementation of session types in ATS. In addition, we gain immediate support for a form of dependent session types based on this embedding into ATS. Compared to various existing formalizations of session types, we see the one given in this paper is unique in its closeness to concrete implementation. In particular, we report such an implementation ready for practical use that generates Erlang code from well-typed ATS source (making use of session types), thus taking great advantage of the infrastructural support for distributed computing in Erlang.},
  archivePrefix = {arXiv},
  author = {Xi, Hongwei and Ren, Zhiqiang and Wu, Hanwen and Blair, William},
  eprint = {1603.03727},
  eprinttype = {arxiv},
  file = {/home/uma/references/papers/Xi et al_2016_Session Types in a Linearly Typed Multi-Threaded Lambda-Calculus.pdf},
  journal = {arXiv:1603.03727 [cs]},
  keywords = {Computer Science - Logic in Computer Science,Computer Science - Programming Languages},
  language = {en},
  month = mar,
  primaryClass = {cs},
  title = {Session {{Types}} in a {{Linearly Typed Multi}}-{{Threaded Lambda}}-{{Calculus}}},
  year = {2016}
}


